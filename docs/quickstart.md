# Quickstart

---

## What to expect

- Fully functional API to handle user account
- Both graphQL and Relay versions
- Setup with custom user model
- 20 to 30 minutes

[Final code on github](https://github.com/nrbnlulu/strawberry-django-auth/tree/master/quickstart).

---

## Start a new Django Project

!!! info ""
    It's recommended to use [virtual env wrapper](https://virtualenvwrapper.readthedocs.io/en/latest/index.html) or [virtualenv](https://virtualenv.pypa.io/en/latest/) to create
    your project inside an isolated python environment. We will use the first.

### Create the virtual env

```bash
python -m venv venv
cd venv/bin
source activate.sh
```

### Create the Django Project

First install django:

```bash
python -m pip install django
```

Then, create the new project:

```bash
django-admin startproject quickstart
cd quickstart
```

### Create the custom user model

Changing to a custom user model mid-project is significantly more difficult. So let's start by adding it now. Run the following:

```bash
python manage.py startapp users
```

Then, create the custom user model:

```python
# users/models.py

from django.contrib.auth.models import AbstractUser

class CustomUser(AbstractUser):

    email = models.EmailField(blank=False, max_length=254, verbose_name="email address")

    USERNAME_FIELD = "username"   # e.g: "username", "email"
    EMAIL_FIELD = "email"         # e.g: "email", "primary_email"
```

Add it to the settings:

```python
# quickstart/settings.py

INSTALLED_APPS = [
    # ...
    'users'
]

AUTH_USER_MODEL = 'users.CustomUser'
```

Finally, migrate:

```bash
python manage.py migrate
```

!!! info ""
    You can customize the mutations to match your custom user model fields, see the [dynamic-fields settings](settings.md).

---

## Setup strawberry and strawberry-jwt

??? Question "What is strawberry-django?"
    [strawberry-django](https://github.com/strawberry-graphql/strawberry-graphql-django)
    is small wrapper around strawberry that makes it easy to integrate strawberry with django.
    although we utilize it only for user queries, mutations are pure strawberry.

??? Question "What is strawberry-django-jwt?"
    [strawberry-django-jwt](https://github.com/KundaPanda/strawberry-django-jwt)
    is a forked version of [Django-Graphql-Jwt](https://django-graphql-jwt.domake.io/en/latest/index.html)
    and is the easiest way to add JSON Web token authentication for Django with strawberry.


??? Note "strawberry-django quick start - copied"

    ### Installation

    ```bash
    python -m pip install strawberry_graphql_django
    ```
    ### Add the url

    ```python
    # quickstart.urls.py

    from django.urls import path
    from django.views.decorators.csrf import csrf_exempt

    from strawberry.django.views import GraphQLView

    urlpatterns = [
        # ...
        path("graphql", csrf_exempt(GraphQLView.as_view(graphiql=True))),
    ]
    ```


    ## Sample project

    Let's start from Django model called Fruit, which has two attributes, name and color.

    ```python
    # models.py
    from django.db import models

    class Fruit(models.Model):
        name = models.CharField(max_length=20)
        color = models.CharField(max_length=20)
    ```

    Soon after that your Boss comes and asks you to implement API for that model so that everyone can access our great fruit database from all over the world.

    Fruit model has name and color attributes and we want to publish them both. GraphQL output type for our model is generated by using `strawberry_django.type` decorator. Both fields are char fields which means that we want to use python `str`type for them.

    ```python
    # types.py
    import strawberry_django
    from . import models

    @strawberry_django.type(models.Fruit)
    class Fruit:
        name: str
        color: str
    ```

    Last step is to generate Query type and Schema. Core package `strawberry` helps us here.

    ```python
    # schema.py
    import strawberry
    from typing import List
    from .types import Fruit

    @strawberry.type
    class Query:
        fruits: List[Fruit] = strawberry.django.field()

    schema = strawberry.Schema(query=Query)
    ```

    Finally we add `AsyncGraphQLView` view into our urls so that we can start making first queries.

    ```python
    # urls.py
    from django.urls import include, path
    from strawberry.django.views import AsyncGraphQLView
    from .schema import schema

    urlpatterns = [
        path('graphql', AsyncGraphQLView.as_view(schema=schema)),
    ]
    ```

    After that, once the development server is running, you can read your fruits from the database.

    ```graphql
    query {
      fruits {
        name
        color
      }
    }
    # -> fruits: [{ name: "strawberry", color: "red" }]
    ```

    ## Model Relations

    Let's create another model called `Color` and add foreign key relation between `Fruit` and `Color` models.

    ```python
    # models.py
    from django.db import models

    class Fruit(models.Model):
        name = models.CharField(max_length=20)
        color = models.ForeignKey('Color', related_name='fruits', on_delete=models.CASCADE)

    class Color(models.Model):
        name = models.CharField(max_length=20)
    ```

    We also need to add another type and modify existing one. Field type `auto` is used for type auto resolution. `strawberry_django` goes through all fields and resolves field types. It also generates resolvers for relation fields on behalf you.

    ```python
    # types.py
    import strawberry_django
    from strawberry import auto
    from typing import List
    from . import models

    @strawberry_django.type(models.Fruit)
    class Fruit:
        id: auto
        name: auto
        color: 'Color'

    @strawberry_django.type(models.Color)
    class Color:
        id: auto
        name: auto
        fruits: List[Fruit]
    ```

    This generates schema like this

    ```graphql
    type Color {
      id: ID!
      name: String!
      fruits: [Fruit!]
    }

    type Fruit {
      id: ID!
      name: String!
      color: Color!
    }

    type Query {
      fruits: [Fruit!]!
    }
    ```

    Now you can start making queries and request all fruits and their colors from the database.

    ```graphql
    query {
      fruits {
        name
        color {
          name
        }
      }
    }
    # fruits: [
    #   { name: "strawberry", color: { name: "red" } },
    #   { name: "raspberry", color: { name: "red" } }
    # ]
    ```

??? Note "strawberry-django-jwt setup - copied"
    	## Installation

	1. Install last stable version from Pypi:

	   ```shell
	   pip install strawberry-django-jwt
	   ```

	2. Add `AuthenticationMiddleware` middleware to your **MIDDLEWARE** settings:

	   ```python
	   MIDDLEWARE = [
	       ...,
	       'django.contrib.auth.middleware.AuthenticationMiddleware',
	       ...,
	   ]
	   ```

	3. Add following django apps to **INSTALLED_APPS**:

	   ```python
	   INSTALLED_APPS = [
	       'django.contrib.auth',
	       'django.contrib.contenttypes',
	       'django.contrib.sessions',
	       ...,
	   ]
	   ```

	   If using refresh tokens, also add `strawberry_django_jwt.refresh_token`

	   ```python
	   INSTALLED_APPS = [
	       'django.contrib.auth',
	       'django.contrib.contenttypes',
	       'django.contrib.sessions',
	       ...,
	       'strawberry_django_jwt.refresh_token',
	       ...,
	   ]
	   ```

	4. Add `JSONWebTokenMiddleware` or `AsyncJSONWebTokenMiddleware` middleware to your **STRAWBERRY** schema definition:

	   ```python
	   from strawberry_django_jwt.middleware import JSONWebTokenMiddleware, AsyncJSONWebTokenMiddleware
	   from strawberry import Schema

	   # !! IMPORTANT !!
	   # Pick only one, async middleware is needed when using AsyncGraphQLSchema
	   schema = Schema(..., extensions=[
	      JSONWebTokenMiddleware,
	      AsyncJSONWebTokenMiddleware,
	   ])
	   ```

	5. Add `JSONWebTokenBackend` backend to your **AUTHENTICATION_BACKENDS**:

	   ```python
	   AUTHENTICATION_BACKENDS = [
	       'strawberry_django_jwt.backends.JSONWebTokenBackend',
	       'django.contrib.auth.backends.ModelBackend',
	   ]
	   ```

	6. Add _strawberry-django-jwt_ mutations to the root schema:

	   ```python
	   import strawberry
	   import strawberry_django_jwt.mutations as jwt_mutations

	   @strawberry.type
	   class Mutation:
	       token_auth = jwt_mutations.ObtainJSONWebToken.obtain
	       verify_token = jwt_mutations.Verify.verify
	       refresh_token = jwt_mutations.Refresh.refresh
	       delete_token_cookie = jwt_mutations.DeleteJSONWebTokenCookie.delete_cookie
	   ```

	   schema = strawberry.Schema(mutation=Mutation, query=...)

	7. \[OPTIONAL\] Set up the custom Strawberry views

	   These views set the status code of failed authentication attempts to 401 instead of the default 200.

	   ```python
	   from django.urls import re_path
	   from strawberry_django_jwt.decorators import jwt_cookie
	   from strawberry_django_jwt.views import StatusHandlingGraphQLView as GQLView
	   from ... import schema

	   urlpatterns += \
	   [
	       re_path(r'^graphql/?$', jwt_cookie(GQLView.as_view(schema=schema))),
	   ]
	   ```

	   or, for async views:

	   ```python
	   from django.urls import re_path
	   from strawberry_django_jwt.decorators import jwt_cookie
	   from strawberry_django_jwt.views import AsyncStatusHandlingGraphQLView as AGQLView
	   from ... import schema

	   urlpatterns += \
	   [
	       re_path(r'^graphql/?$', jwt_cookie(AGQLView.as_view(schema=schema))),
	   ]
	   ```

	---

	## Known Issues

	- `JWT_ALLOW_ANY_CLASSES`

	  - Only supports return-type based filtering at the moment, because strawberry does not use class-based field
	    definitions (so all superclasses are dropped)

	  - It might be possible to create a workaround by using either a class decorator or by creating a custom graphql
	    scheme that somehow preserves class hierarchy of types

---

#### After you are done with strawberry-django initialization your settings should look like this:

```python
# quickstart.settings.py

INSTALLED_APPS = [
    # ...
    'django.contrib.staticfiles', # Required for GraphiQL
    "strawberry_django",

    # refresh tokens are optional
    "strawberry_django_jwt.refresh_token",
]

MIDDLEWARE = [
    # ...
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    # ...
]


AUTHENTICATION_BACKENDS = [
    'strawberry_django_jwt.backends.JSONWebTokenBackend',
    'django.contrib.auth.backends.ModelBackend',
]

GRAPHQL_JWT = {
    "JWT_VERIFY_EXPIRATION": True,

    # optional
    "JWT_LONG_RUNNING_REFRESH_TOKEN": True,
}
```

If you choose to use the refresh tokens, remember to migrate:

```bash
python -m manage migrate
```

---

## Install strawberry-django-auth

```bash
pip install strawberry-django-auth
```

```python
# settings.py

INSTALLED_APPS = [
    # ...
    "gqlauth",
]
```

[Here](installation.md#3-authentication-backend-optional) is an explanation why we are adding this backend.

And make sure your templates configuration has the following:

```python
TEMPLATES = [
    {
        # ...
        'APP_DIRS': True,
    },
]
```
Run:

```bash
python -m manage migrate
```


Now let's disable captcha validation for setup ease.
in your settings.py add the following:
```py
# settings.py
from gqlauth.settings_type import GqlAuthSettings

GQL_AUTH = GqlAuthSettings(
    LOGIN_REQUIRE_CAPTCHA=False,
    REGISTER_REQUIRE_CAPTCHA=False,
)
```

!!! Warning
    #### these (captcha) settings can not be changed at runtime!
    #### since the schema can not be changed at runtime.


## Query

---
### Create the schema

Create a file called ``schema.py`` next to your ``settings.py`` with the following:

!!! Important "Do not forget to add the extensions or no authentication will occur."

```python
# quickstart.schema.py

import strawberry
from gqlauth.user.queries import UserQueries
# can be async too `AsyncJSONWebTokenMiddleware`
from gqlauth.extensions import GqlAuthJSONWebTokenMiddleware

schema = strawberry.Schema(
    query=UserQueries,
    extensions=[
        GqlAuthJSONWebTokenMiddleware,
    ],
)

```

??? Note "you can choose what fields to include like this"

    ```python
    import strawberry
    from gqlauth.user.queries import UserQueries, UserType
    from django.contrib.auth import get_user_model

    @strawberry.django.type(model=get_user_model())
    class MyQueries:
        me: UserType = UserQueries.me
        public: UserType = UserQueries.public_user
        # etc...
    ```

### Load fixtures

---
Before starting to query, let's load some users on the database. Create a new file called ``users.json`` in the same directory as ``manage.py`` with the following:

!!! info ""
    Have a look on the fixtures, note that we are creating 4 users and 3 `UserStatus`. When creating a user, we create a relating `UserStatus` by default on `post_save` signal with the following fields:

    ```python
    verified=False
    archived=False
    secondary_email=None
    ```

    You can access it on any user:

    ```bash
    user.status.[verified | archived | secondary_email]
    ```

```json
[
  {
      "model": "users.CustomUser",
      "pk": 1,
      "fields": {
          "password": "pbkdf2_sha256$180000$nFcBtiqGnWN9$hf58wNg77oT1BlNKRdATVVvBIa69+dz22fL1JKOKTaA=",
          "last_login": null,
          "is_superuser": false,
          "username": "user1",
          "first_name": "",
          "last_name": "",
          "email": "user1@email.com",
          "is_staff": false,
          "is_active": true
      }
  },
  {
      "model": "users.CustomUser",
      "pk": 2,
      "fields": {
          "password": "pbkdf2_sha256$180000$nFcBtiqGnWN9$hf58wNg77oT1BlNKRdATVVvBIa69+dz22fL1JKOKTaA=",
          "last_login": null,
          "is_superuser": false,
          "username": "user2",
          "first_name": "",
          "last_name": "",
          "email": "user2@email.com",
          "is_staff": false,
          "is_active": true
      }
  },
  {
      "model": "gqlauth.userstatus",
      "pk": 2,
      "fields": {
          "user": 2,
          "verified": true,
          "archived": false,
          "secondary_email": null
      }
  },
  {
      "model": "users.CustomUser",
      "pk": 3,
      "fields": {
          "password": "pbkdf2_sha256$180000$nFcBtiqGnWN9$hf58wNg77oT1BlNKRdATVVvBIa69+dz22fL1JKOKTaA=",
          "last_login": null,
          "is_superuser": false,
          "username": "user3",
          "first_name": "",
          "last_name": "",
          "email": "user3@email.com",
          "is_staff": false,
          "is_active": true
      }
  },
  {
      "model": "gqlauth.userstatus",
      "pk": 3,
      "fields": {
          "user": 3,
          "verified": true,
          "archived": true,
          "secondary_email": null
      }
  },
  {
      "model": "users.CustomUser",
      "pk": 4,
      "fields": {
          "password": "pbkdf2_sha256$180000$nFcBtiqGnWN9$hf58wNg77oT1BlNKRdATVVvBIa69+dz22fL1JKOKTaA=",
          "last_login": null,
          "is_superuser": false,
          "username": "user4",
          "first_name": "",
          "last_name": "",
          "email": "user4@email.com",
          "is_staff": false,
          "is_active": true
      }
  },
  {
      "model": "gqlauth.userstatus",
      "pk": 4,
      "fields": {
          "user": 4,
          "verified": true,
          "archived": false,
          "secondary_email": "user4_secondary@email.com"
      }
  }
]


```

run:

```bash
python -m  manage loaddata users.json
```


### Making your first query

---

Start the dev server:

```bash
python manage.py runserver
```

Open your browser:

```bash
http://127.0.0.1:8000/graphql
```

!!! info ""
    This will open the [GraphiQL API browser](https://github.com/graphql/graphiql),
    where you can play with your queries and mutations, also let you explore the schema.

Copy the query below, paste on the GraphiQL interface and hit the play button.

!!! Gql
    === "query"

        ```gql
        query {
          users{
                username,
                archived,
                verified,
                email,
                secondaryEmail,
              }
            }

        ```
    === "response"

        ```json
        {
          "data": {
            "users": [
              {
                "username": "user1",
                "archived": false,
                "verified": false,
                "email": "user1@email.com",
                "secondaryEmail": null
              },
              {
                "username": "user2",
                "archived": false,
                "verified": true,
                "email": "user2@email.com",
                "secondaryEmail": null
              },
              {
                "username": "user3",
                "archived": true,
                "verified": true,
                "email": "user3@email.com",
                "secondaryEmail": null
              },
              {
                "username": "user4",
                "archived": false,
                "verified": true,
                "email": "user4@email.com",
                "secondaryEmail": "user4_secondary@email.com"
              }
            ]
          }
        }
        ```

### Query with filters

The ``UserQuery`` comes with some default filters:
!!! gql
    === "query"
        ```gql
        {
          users(filters: {status: {archived: true}}) {
            username
            archived
            verified
            email
            secondaryEmail
          }
        }

        ```
    === "response"
        ```
        {
          "data": {
            "users": [
              {
                "username": "user3",
                "archived": true,
                "verified": true,
                "email": "user3@email.com",
                "secondaryEmail": null
              }
            ]
          }
        }
        ```

Take a minute to explore the GraphiQL API browser and query schema on the right upper
corner under docs tab.

### MeQuery

With ``MeQuery`` you can retrieve data for the currently authenticated user:
!!! Gql
    === "query"
        ```
        query {
          me {
            username,
            verified
          }
        }
        ```
    === "response"
        ```
        {
          "data": {
            "user": {
              "username": "new_user",
              "verified": true
            }
          }
        }
        ```

Since this query requires an authenticated user it can only be explored by using the [insomnia API client](https://insomnia.rest/). See the below for more on how to use Insomnia.

## Setup Email Backend
___

The default configuration is to send activation email when registering users,
you can set it to ``False`` on your [settings](settings.md),
but you still need an Email Backend
to password reset.

The quickest solution for development is to setup a [Console Email Backend](https://docs.djangoproject.com/en/3.0/topics/email/#console-backend), simply add the following to your ```settings.py```.

```python
EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend'
```

Now all emails are sent to the standard output, instead of an actual email and we
are ready to continue this guide.

## Mutations
___

Now let's add some mutations to our schema, starting with the registration. On the ``schema.py`` add the following:

!!! Register
    === "arg_mutations"
        ```python hl_lines="5"
        # quickstart.schema.py

        import strawberry
        from gqlauth.schema import UserQueries
        from gqlauth.user import arg_mutations
        from strawberry_django_jwt.middleware import JSONWebTokenMiddleware


        @strawberry.type
        class UserMutations:
            register = arg_mutations.Register.field
            verify_account = arg_mutations.VerifyAccount.field
            resend_activation_email = arg_mutations.ResendActivationEmail.field
            send_password_reset_email = arg_mutations.SendPasswordResetEmail.field
            password_reset = arg_mutations.PasswordReset.field
            password_set = arg_mutations.PasswordSet.field
            password_change = arg_mutations.PasswordChange.field
            archive_account = arg_mutations.ArchiveAccount.field
            delete_account = arg_mutations.DeleteAccount.field
            update_account = arg_mutations.UpdateAccount.field
            send_secondary_email_activation = arg_mutations.SendSecondaryEmailActivation.field
            verify_secondary_email = arg_mutations.VerifySecondaryEmail.field
            swap_emails = arg_mutations.SwapEmails.field
            captcha = arg_mutations.Cap.field

            # django-graphql-jwt authentication
            # with some extra features
            token_auth = arg_mutations.ObtainJSONWebToken.field
            verify_token = arg_mutations.VerifyToken.field
            refresh_token = arg_mutations.RefreshToken.field
            revoke_token = arg_mutations.RevokeToken.field

        schema = strawberry.Schema(
                    query=UserQueries,
                    mutation=UserMutations,
                    extensions=[
                        JSONWebTokenMiddleware,
                    ],
                )
        ```
    === "relay"
        ```python hl_lines="5"

        # quickstart.schema.py

        import strawberry
        from gqlauth.schema import UserQueries
        from gqlauth.user import relay
        from strawberry_django_jwt.middleware import JSONWebTokenMiddleware

        @strawberry.type
        class UserMutations:
            register = relay.Register.field
            verify_account = relay.VerifyAccount.field
            resend_activation_email = relay.ResendActivationEmail.field
            send_password_reset_email = relay.SendPasswordResetEmail.field
            password_reset = relay.PasswordReset.field
            password_set = relay.PasswordSet.field
            password_change = relay.PasswordChange.field
            archive_account = relay.ArchiveAccount.field
            delete_account = relay.DeleteAccount.field
            update_account = relay.UpdateAccount.field
            send_secondary_email_activation = relay.SendSecondaryEmailActivation.field
            verify_secondary_email = relay.VerifySecondaryEmail.field
            swap_emails = relay.SwapEmails.field
            captcha = relay.Cap.field

            # django-graphql-jwt authentication
            # with some extra features
            token_auth = relay.ObtainJSONWebToken.field
            verify_token = relay.VerifyToken.field
            refresh_token = relay.RefreshToken.field
            revoke_token = relay.RevokeToken.field

        schema = strawberry.Schema(
                    query=UserQueries,
                    mutation=UserMutations,
                    extensions=[
                        JSONWebTokenMiddleware,
                    ],
                )
        ```

Take a minute to explore the schema on the documentation tab again.


[//]: # (On your `#!python GRAPHQL_JWT["JWT_ALLOW_ANY_CLASSES"]` setting, add the following:)

[//]: # ()
[//]: # (```python tab="GraphQL")

[//]: # (GRAPHQL_JWT = {)

[//]: # (    #...)

[//]: # (    "JWT_ALLOW_ANY_CLASSES": [)

[//]: # (        "gqlauth.mutations.Register",)

[//]: # (    ],)

[//]: # (})

[//]: # (```)

[//]: # ()
[//]: # (```python tab="Relay")

[//]: # (GRAPHQL_JWT = {)

[//]: # (    #...)

[//]: # (    "JWT_ALLOW_ANY_CLASSES": [)

[//]: # (        "gqlauth.relay.Register",)

[//]: # (    ],)

[//]: # (})

[//]: # (```)

### Let's try to register a new user:
!!! failure
    === "gql"
        ```pytohn hl_lines="5 6"
        mutation {
          register(
            email: "new_user@email.com",
            username: "new_user",
            password1: "123456",
            password2: "123456",
          ) {
            success,
            errors,
          }
        }
        ```
    === "relay"
        ```gql hl_lines="3 8"
        mutation {
          register(
            input: {
              email: "new_user@email.com",
              username: "new_user",
              password1: "123456",
              password2: "123456",
            }
          ) {
            success,
            errors,
            token,
            refreshToken
          }
        }
        ```
    === "response"
        ```json
            {
              "data": {
                "register": {
                  "success": false,
                  "errors": {
                    "password2": [
                      {
                        "message": "This password is too short. It must contain at least 8 characters.",
                        "code": "password_too_short"
                      },
                      {
                        "message": "This password is too common.",
                        "code": "password_too_common"
                      },
                      {
                        "message": "This password is entirely numeric.",
                        "code": "password_entirely_numeric"
                      }
                    ]
                  }
                }
              }
            }
        ```
Something went wrong! Now you know the response format that you can expect of
all mutations.

Let's try again:

!!! success
    === "arg_mutation"
        ```gql hl_lines="5 6"
        mutation {
          register(
            email: "new_user@email.com",
            username: "new_user",
            password1: "SuperSecureP@sw0rd",
            password2: "SuperSecureP@sw0rd",
          ) {
            success,
            errors,
            success
          }
        }
        ```
    === "relay"

        ```gql hl_lines="3 8"
        mutation {
          register(
            input: {
              email: "new_user@email.com",
              username: "new_user",
              password1: "SuperSecureP@sw0rd",
              password2: "SuperSecureP@sw0rd",
            }
          ) {
            success,
            errors,
            token,
            refreshToken
          }
        }
        ```

    === "response"
        ```json
        {
          "data": {
            "register": {
              "success": true,
              "errors": null
            }
          }
        }
        ```



Now Check if the new user is really on the database:
??? check
    === "query"
        ```gql
        query{
          users(filters: {username: "new_user"}) {
            id
            username
            email
                isActive
            archived,
            verified,
            secondaryEmail
          }
        }
        ```
    === "response"
        ```json hl_lines="8"
        {
          "data": {
            "users": [
              {
                "id": "5",
                "username": "new_user",
                "email": "new_user@email.com",
                "isActive": true,
                "archived": false,
                "verified": false,
                "secondaryEmail": null
              }
            ]
          }
        }
        ```

There is actually a new user and it is possible to log in (you can change it on the [settings](settings.md)),
but it is not verified yet.

Save the ``id`` of the new user, so we can query it later.

Go to your console and note the email that has been sent. Should be two outputs, html and plain text formats.

Save the token from the url, something like this:

```bash
eyJ1c2VybmFtZSI6Im5ld191c2VyIiwiYWN0aW9uIjoiYWN0aXZhdGlvbiJ9:1isoSr:CDwK_fjBSxWj3adC-X16wqzv-Mw
```

### Account Verification

---

search your schema for ``verify_account``:
should look like this:
![Verify-account](images/verify-acount-screen-shot.png)

#### Now let's try to verify the account:

!!! gql
    === "arg_mutation"
        ```gql
        mutation {
          verifyAccount(token: "YOUR TOKEN HERE") {
            success,
            errors
          }
        }
        ```
    === "relay"
        ```python hl_lines="3 5"
            mutation {
              verifyAccount(
                input: {
                  token: "<YOUR TOKEN HERE>"
                }
              )
              {
                success,
                errors
              }
            }
        ```
    === "result"
        ```json
        {
          "data": {
            "verifyAccount": {
              "success": true,
              "errors": null
            }
          }
        }
        ```



Check if the user is verified using the id that you have saved early:

!!! gql
    === "query"
        ```gql
        query {
          user (pk: "<USER ID>"){
            username,
            verified
          }
        }
        ```
    === "response"
        ```json hl_lines="5"
        {
          "data": {
            "user": {
              "username": "new_user",
              "verified": true
            }
          }
        }
        ```


## Login

---
search your schema for ``tokenAuth``:
should look like this:
![Verify-account](images/token-auth.png)

#### Let's try to login:

!!! gql
    === "arg_mutation"
        ```gql
        mutation {
          tokenAuth(username: "new_user", password: "SuperSecureP@sw0rd") {
            success
            errors
            obtainPayload {
              token
              refreshToken
              refreshExpiresIn
              payload {
                exp
                origIat
                username
              }
            }
          }
        }
        ```
    === "relay"
        ```gql hl_lines="3 6"
        mutation login {
          tokenAuth(input: {username: "new_user", password: "SuperSecureP@sw0rd"}) {
            success
            errors
            obtainPayload {
              token
              refreshToken
              refreshExpiresIn
              payload {
                exp
                origIat
                username
              }
            }
          }
        }
        ```
    === "response"

        ```json
        {
          "data": {
            "tokenAuth": {
              "success": true,
              "errors": null,
              "obtainPayload": {
                "token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE2NTM2MDkxOTQsIm9yaWdJYXQiOjE2NTM2MDg4OTQsInVzZXJuYW1lIjoibmV3X3VzZXIxIn0.FxXaWKToi5mTzPcKAz16K2GWnIvsTBKio_BEyCdF5fs",
                "refreshToken": "e7a784476810f880eb93f3827cd881d834235598",
                "refreshExpiresIn": 1654213694,
                "payload": {
                  "exp": 1653609194,
                  "origIat": 1653608894,
                  "username": "new_user1"
                }
              }
            }
          }
        }
        ```



Save this `token`, we are going to use it to do some protected actions.

The GraphiQL interface that comes with Graphene is great! But to try all features, we need to send this token on the header and the GraphiQL do not support this.

---

### Insomnia API client

We are going to use [insomnia API client](https://insomnia.rest/) to send request with authorization header. It is really easy to setup, simple follow the instructions on the site.

Install and come back here!

### Update Account

---
search in your schema for `updateAccount`
it should look like this:
![update-account](images/update_acount.png)

This is the first mutation with login required that we are going to test.


On the insomnia, create a new request and call it `updateAccount`. Select the method `POST`.
On the top of the window, add your graphql url:

```bash
http://127.0.0.1:8000/graphql
```

For the body, select `GraphQL Query`. Now it works exactly as the graphiQL.

On the headers pane, create a new header:

- name: `Authorization`
- value: `JWT <TOKEN FROM THE LOGIN>`

Make the query:
!!! gql
    === "arg_mutation"
        ```gql
        mutation {
          updateAccount(
            firstName: "Joe"
          ) {
            success,
            errors
          }
        }
        ```
    === "relay"
        ``` hl_lines="3 5"
        mutation {
          updateAccount(
            input: {
              firstName: "Joe"
            }
          ) {
            success,
            errors
          }
        }
        ```

    === "response"
        ```json
        {
          "data": {
            "updateAccount": {
              "success": true,
              "errors": null
            }
          }
        }
        ```


!!! tip ""
    If it fails because of the token (in case you took some time and it has expired), make the login again and get a new token.

Check if it worked:
!!! gql
    === "query"
        ```gql
        query {
          user (id: "<USER ID>"){
            username,
            firstName
          }
        }
        ```
    === "response"
        ```json
        {
          "data": {
            "user": {
              "username": "new_user",
              "firstName": "Joe"
            }
          }
        }
        ```

---

## Next steps

- explore all the mutations.
- Navigate through the GraphiQL Documentation Explorer.
- Change the [settings](settings.md).
- Explore the [api](api.md).
- check our [decorators](decorators.md).
- make sure you are familiar with our [captcha](captcha.md) system.
- [Override email templates](overriding-email-templates.md).
- Explore [these useful links](community.md).
