{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Strawberry Graphql Auth \u00b6 Registration and authentication with strawberry and django. Demo \u00b6 About \u00b6 Abstract all the basic logic of handling user accounts out of your app, so you don't need to think about it and can get you up and running faster . No lock-in. When you are ready to implement your own code or this package is not up to your expectations , it's easy to extend or switch to your implementation . Features \u00b6 Awesome docs! Captcha validation Async/Sync supported! Works with default or custom user model JWT authentication (with Strawberry Django JWT ) User registration with email verification Add secondary email, with email verification too Resend activation email Retrieve/Update user Archive user Permanently delete user or make it inactive Turn archived user active again on login Track user status (archived, verified, secondary email) Password change Password reset through email Revoke user tokens on account archive/delete/password change/reset All mutations return success and errors Default email templates (you will customize though) Customizable, no lock-in Passwordless registration Currently, only mutations are compatible with Relay Example \u00b6 Handling user accounts becomes super easy. mutation { register ( email : \"new_user@email.com\" , username : \"new_user\" , password1 : \"123456super\" , password2 : \"123456super\" , ) { success , errors , token , refreshToken } } Check the status of the new user: u = UserModel . objects . last () u . status . verified # False During the registration, an email with a verification link was sent. mutation { verifyAccount ( token : \"<TOKEN ON EMAIL LINK>\" , ) { success , errors } } Now user is verified. u . status . verified # True Check the installation guide or jump to the quickstart . Or if you prefer, browse the api .","title":"Start here"},{"location":"#strawberry-graphql-auth","text":"Registration and authentication with strawberry and django.","title":"Strawberry Graphql Auth"},{"location":"#demo","text":"","title":"Demo"},{"location":"#about","text":"Abstract all the basic logic of handling user accounts out of your app, so you don't need to think about it and can get you up and running faster . No lock-in. When you are ready to implement your own code or this package is not up to your expectations , it's easy to extend or switch to your implementation .","title":"About"},{"location":"#features","text":"Awesome docs! Captcha validation Async/Sync supported! Works with default or custom user model JWT authentication (with Strawberry Django JWT ) User registration with email verification Add secondary email, with email verification too Resend activation email Retrieve/Update user Archive user Permanently delete user or make it inactive Turn archived user active again on login Track user status (archived, verified, secondary email) Password change Password reset through email Revoke user tokens on account archive/delete/password change/reset All mutations return success and errors Default email templates (you will customize though) Customizable, no lock-in Passwordless registration Currently, only mutations are compatible with Relay","title":"Features"},{"location":"#example","text":"Handling user accounts becomes super easy. mutation { register ( email : \"new_user@email.com\" , username : \"new_user\" , password1 : \"123456super\" , password2 : \"123456super\" , ) { success , errors , token , refreshToken } } Check the status of the new user: u = UserModel . objects . last () u . status . verified # False During the registration, an email with a verification link was sent. mutation { verifyAccount ( token : \"<TOKEN ON EMAIL LINK>\" , ) { success , errors } } Now user is verified. u . status . verified # True Check the installation guide or jump to the quickstart . Or if you prefer, browse the api .","title":"Example"},{"location":"api/","text":"auto generated using pydoc_markdown asdict \u00b6 SMTPException \u00b6 Union \u00b6 UUID \u00b6 async_to_sync \u00b6 sync_to_async \u00b6 get_user_model \u00b6 PasswordChangeForm \u00b6 SetPasswordForm \u00b6 ObjectDoesNotExist \u00b6 BadSignature \u00b6 SignatureExpired \u00b6 transaction \u00b6 strawberry \u00b6 Info \u00b6 JSONWebTokenError \u00b6 JSONWebTokenExpired \u00b6 JwtObtainParent \u00b6 RefreshParent \u00b6 RevokeParent \u00b6 VerifyParent \u00b6 create_user_token \u00b6 MutationNormalOutput \u00b6 ObtainJSONWebTokenPayload \u00b6 RefreshTokenPayload \u00b6 RevokeTokenPayload \u00b6 VerifyTokenPayload \u00b6 Messages \u00b6 TokenAction \u00b6 _password_confirmation_required \u00b6 secondary_email_required \u00b6 verification_required \u00b6 EmailAlreadyInUse \u00b6 InvalidCredentials \u00b6 PasswordAlreadySetError \u00b6 TokenScopeError \u00b6 UserAlreadyVerified \u00b6 UserNotVerified \u00b6 EmailForm \u00b6 PasswordLessRegisterForm \u00b6 RegisterForm \u00b6 UpdateAccountForm \u00b6 CaptchaModel \u00b6 UserStatus \u00b6 app_settings \u00b6 get_user_by_email \u00b6 get_user_to_login \u00b6 user_registered \u00b6 user_verified \u00b6 CaptchaType \u00b6 g_user \u00b6 get_payload_from_token \u00b6 inject_fields \u00b6 revoke_user_refresh_token \u00b6 UserModel \u00b6 Captcha \u00b6 class Captcha () Creates a brand-new captcha. Returns a base64 encoded string of the captcha. And uuid representing the captcha id in the database. When you will try to log in or register You will need submit that uuid With the user input. The captcha will be invoked when the timeout expires . field \u00b6 @strawberry . mutation ( description = __doc__ ) def field () -> CaptchaType afield \u00b6 @strawberry . mutation ( description = __doc__ ) @sync_to_async def afield () -> CaptchaType check_captcha \u00b6 def check_captcha ( input_ : Union [ \"RegisterMixin.RegisterInput\" , \"ObtainJSONWebTokenMixin.ObtainJSONWebTokenInput\" ]) RegisterMixin \u00b6 class RegisterMixin () Register user with fields defined in the settings. If the email field of the user model is part of the registration fields (default), check if there is no user with that email or as a secondary email. If it exists, it does not register the user, even if the email field is not defined as unique (default of the default django user model). When creating the user, it also creates a UserStatus related to that user, making it possible to track if the user is archived, verified and has a secondary email. Send account verification email. If allowed to not verified users login, return token. RegisterInput \u00b6 @strawberry . input @inject_fields ( app_settings . REGISTER_MUTATION_FIELDS ) class RegisterInput () form \u00b6 resolve_mutation \u00b6 @classmethod def resolve_mutation ( cls , info , input_ : RegisterInput ) -> MutationNormalOutput VerifyAccountMixin \u00b6 class VerifyAccountMixin () Verify user account. Receive the token that was sent by email. If the token is valid, make the user verified by making the user.status.verified field true. VerifyAccountInput \u00b6 @strawberry . input class VerifyAccountInput () token \u00b6 resolve_mutation \u00b6 @classmethod def resolve_mutation ( cls , info : Info , input_ : VerifyAccountInput ) -> MutationNormalOutput VerifySecondaryEmailMixin \u00b6 class VerifySecondaryEmailMixin () Verify user secondary email. Receive the token that was sent by email. User is already verified when using this mutation. If the token is valid, add the secondary email to user.status.secondary_email field. Note that until the secondary email is verified, it has not been saved anywhere beyond the token, so it can still be used to create a new account. After being verified, it will no longer be available. VerifySecondaryEmailInput \u00b6 @strawberry . input class VerifySecondaryEmailInput () token \u00b6 resolve_mutation \u00b6 @classmethod def resolve_mutation ( cls , _ , input_ : VerifySecondaryEmailInput ) -> MutationNormalOutput ResendActivationEmailMixin \u00b6 class ResendActivationEmailMixin () Sends activation email. It is called resend because theoretically the first activation email was sent when the user registered. If there is no user with the requested email, a successful response is returned. ResendActivationEmailInput \u00b6 @strawberry . input class ResendActivationEmailInput () email \u00b6 resolve_mutation \u00b6 @classmethod def resolve_mutation ( cls , info , input_ : ResendActivationEmailInput ) -> MutationNormalOutput SendPasswordResetEmailMixin \u00b6 class SendPasswordResetEmailMixin () Send password reset email. For non verified users, send an activation email instead. Accepts both primary and secondary email. If there is no user with the requested email, a successful response is returned. SendPasswordResetEmailInput \u00b6 @strawberry . input class SendPasswordResetEmailInput () email \u00b6 resolve_mutation \u00b6 @classmethod def resolve_mutation ( cls , info , input_ : SendPasswordResetEmailInput ) -> MutationNormalOutput PasswordResetMixin \u00b6 class PasswordResetMixin () Change user password without old password. Receive the token that was sent by email. If token and new passwords are valid, update user password and in case of using refresh tokens, revoke all of them. Also, if user has not been verified yet, verify it. PasswordResetInput \u00b6 @strawberry . input class PasswordResetInput () token \u00b6 new_password1 \u00b6 new_password2 \u00b6 form \u00b6 resolve_mutation \u00b6 @classmethod def resolve_mutation ( cls , _ , input_ : PasswordResetInput ) -> MutationNormalOutput PasswordSetMixin \u00b6 class PasswordSetMixin () Set user password - for password-less registration Receive the token that was sent by email. If token and new passwords are valid, set user password and in case of using refresh tokens, revoke all of them. Also, if user has not been verified yet, verify it. PasswordSetInput \u00b6 @strawberry . input class PasswordSetInput () token \u00b6 new_password1 \u00b6 new_password2 \u00b6 form \u00b6 resolve_mutation \u00b6 @classmethod def resolve_mutation ( cls , _ , input_ : PasswordSetInput ) -> MutationNormalOutput ObtainJSONWebTokenMixin \u00b6 class ObtainJSONWebTokenMixin () Obtain JSON web token for given user. Allow to perform login with different fields, and secondary email if set. The fields are defined on settings. Not verified users can log in by default. This can be changes on settings. If user is archived, make it unarchived and return unarchiving=True on OutputBase. ObtainJSONWebTokenInput \u00b6 @strawberry . input @inject_fields ( app_settings . LOGIN_FIELDS ) class ObtainJSONWebTokenInput () password \u00b6 resolve_mutation \u00b6 @classmethod def resolve_mutation ( cls , info , input_ : ObtainJSONWebTokenInput ) -> ObtainJSONWebTokenPayload ArchiveOrDeleteMixin \u00b6 class ArchiveOrDeleteMixin () ArchiveOrDeleteMixinInput \u00b6 @strawberry . input class ArchiveOrDeleteMixinInput () password \u00b6 resolve_mutation \u00b6 @classmethod @verification_required @_password_confirmation_required def resolve_mutation ( cls , info , input_ : ArchiveOrDeleteMixinInput ) -> MutationNormalOutput ArchiveAccountMixin \u00b6 class ArchiveAccountMixin ( ArchiveOrDeleteMixin ) Archive account and revoke refresh tokens. User must be verified and confirm password. resolve_action \u00b6 @classmethod def resolve_action ( cls , user ) DeleteAccountMixin \u00b6 class DeleteAccountMixin ( ArchiveOrDeleteMixin ) Delete account permanently or make user.is_active=False . The behavior is defined on settings. Anyway user refresh tokens are revoked. User must be verified and confirm password. resolve_action \u00b6 @classmethod def resolve_action ( cls , user ) PasswordChangeMixin \u00b6 class PasswordChangeMixin () Change account password when user knows the old password. A new token and refresh token are sent. User must be verified. PasswordChangeInput \u00b6 @strawberry . input class PasswordChangeInput () old_password \u00b6 new_password1 \u00b6 new_password2 \u00b6 form \u00b6 resolve_mutation \u00b6 @classmethod @verification_required @_password_confirmation_required def resolve_mutation ( cls , info : Info , input_ : PasswordChangeInput ) -> ObtainJSONWebTokenPayload UpdateAccountMixin \u00b6 class UpdateAccountMixin () Update user model fields, defined on settings. User must be verified. UpdateAccountInput \u00b6 @strawberry . input @inject_fields ( app_settings . UPDATE_MUTATION_FIELDS ) class UpdateAccountInput () form \u00b6 resolve_mutation \u00b6 @classmethod @verification_required def resolve_mutation ( cls , info , input_ : UpdateAccountInput ) -> MutationNormalOutput VerifyTokenMixin \u00b6 class VerifyTokenMixin () Checks if a token is not expired and correct VerifyTokenInput \u00b6 @strawberry . input class VerifyTokenInput () token \u00b6 resolve_mutation \u00b6 @classmethod def resolve_mutation ( cls , info , input_ : VerifyTokenInput ) -> VerifyTokenPayload RefreshTokenMixin \u00b6 class RefreshTokenMixin () refreshToken to refresh your token: \u00b6 using the refresh token you already got during authorization. this will obtain a brand-new token (and possibly a refresh token) with renewed expiration time for non-expired tokens RefreshTokenInput \u00b6 @strawberry . input class RefreshTokenInput () refresh_token \u00b6 resolve_mutation \u00b6 @classmethod def resolve_mutation ( cls , info , input_ : RefreshTokenInput ) -> RefreshTokenPayload RevokeTokenMixin \u00b6 class RevokeTokenMixin () Suspends a refresh token RevokeTokenInput \u00b6 @strawberry . input class RevokeTokenInput () refresh_token \u00b6 resolve_mutation \u00b6 @classmethod def resolve_mutation ( cls , info , input_ : RevokeTokenInput ) -> RevokeTokenPayload SendSecondaryEmailActivationMixin \u00b6 class SendSecondaryEmailActivationMixin () Send activation to secondary email. User must be verified and confirm password. SendSecondaryEmailActivationInput \u00b6 @strawberry . input class SendSecondaryEmailActivationInput () password \u00b6 resolve_mutation \u00b6 @classmethod @verification_required @_password_confirmation_required def resolve_mutation ( cls , info , input_ : SendSecondaryEmailActivationInput ) -> MutationNormalOutput SwapEmailsMixin \u00b6 class SwapEmailsMixin () Swap between primary and secondary emails. Require password confirmation. SwapEmailsInput \u00b6 @strawberry . input class SwapEmailsInput () password \u00b6 resolve_mutation \u00b6 @classmethod @secondary_email_required def resolve_mutation ( cls , info : Info , input_ : SwapEmailsInput ) -> MutationNormalOutput RemoveSecondaryEmailMixin \u00b6 class RemoveSecondaryEmailMixin () Remove user secondary email. Require password confirmation. RemoveSecondaryEmailInput \u00b6 @strawberry . input class RemoveSecondaryEmailInput () password \u00b6 resolve_mutation \u00b6 @classmethod @secondary_email_required @_password_confirmation_required def resolve_mutation ( cls , info : Info , input_ : RemoveSecondaryEmailInput ) -> MutationNormalOutput","title":"API"},{"location":"api/#asdict","text":"","title":"asdict"},{"location":"api/#smtpexception","text":"","title":"SMTPException"},{"location":"api/#union","text":"","title":"Union"},{"location":"api/#uuid","text":"","title":"UUID"},{"location":"api/#async_to_sync","text":"","title":"async_to_sync"},{"location":"api/#sync_to_async","text":"","title":"sync_to_async"},{"location":"api/#get_user_model","text":"","title":"get_user_model"},{"location":"api/#passwordchangeform","text":"","title":"PasswordChangeForm"},{"location":"api/#setpasswordform","text":"","title":"SetPasswordForm"},{"location":"api/#objectdoesnotexist","text":"","title":"ObjectDoesNotExist"},{"location":"api/#badsignature","text":"","title":"BadSignature"},{"location":"api/#signatureexpired","text":"","title":"SignatureExpired"},{"location":"api/#transaction","text":"","title":"transaction"},{"location":"api/#strawberry","text":"","title":"strawberry"},{"location":"api/#info","text":"","title":"Info"},{"location":"api/#jsonwebtokenerror","text":"","title":"JSONWebTokenError"},{"location":"api/#jsonwebtokenexpired","text":"","title":"JSONWebTokenExpired"},{"location":"api/#jwtobtainparent","text":"","title":"JwtObtainParent"},{"location":"api/#refreshparent","text":"","title":"RefreshParent"},{"location":"api/#revokeparent","text":"","title":"RevokeParent"},{"location":"api/#verifyparent","text":"","title":"VerifyParent"},{"location":"api/#create_user_token","text":"","title":"create_user_token"},{"location":"api/#mutationnormaloutput","text":"","title":"MutationNormalOutput"},{"location":"api/#obtainjsonwebtokenpayload","text":"","title":"ObtainJSONWebTokenPayload"},{"location":"api/#refreshtokenpayload","text":"","title":"RefreshTokenPayload"},{"location":"api/#revoketokenpayload","text":"","title":"RevokeTokenPayload"},{"location":"api/#verifytokenpayload","text":"","title":"VerifyTokenPayload"},{"location":"api/#messages","text":"","title":"Messages"},{"location":"api/#tokenaction","text":"","title":"TokenAction"},{"location":"api/#_password_confirmation_required","text":"","title":"_password_confirmation_required"},{"location":"api/#secondary_email_required","text":"","title":"secondary_email_required"},{"location":"api/#verification_required","text":"","title":"verification_required"},{"location":"api/#emailalreadyinuse","text":"","title":"EmailAlreadyInUse"},{"location":"api/#invalidcredentials","text":"","title":"InvalidCredentials"},{"location":"api/#passwordalreadyseterror","text":"","title":"PasswordAlreadySetError"},{"location":"api/#tokenscopeerror","text":"","title":"TokenScopeError"},{"location":"api/#useralreadyverified","text":"","title":"UserAlreadyVerified"},{"location":"api/#usernotverified","text":"","title":"UserNotVerified"},{"location":"api/#emailform","text":"","title":"EmailForm"},{"location":"api/#passwordlessregisterform","text":"","title":"PasswordLessRegisterForm"},{"location":"api/#registerform","text":"","title":"RegisterForm"},{"location":"api/#updateaccountform","text":"","title":"UpdateAccountForm"},{"location":"api/#captchamodel","text":"","title":"CaptchaModel"},{"location":"api/#userstatus","text":"","title":"UserStatus"},{"location":"api/#app_settings","text":"","title":"app_settings"},{"location":"api/#get_user_by_email","text":"","title":"get_user_by_email"},{"location":"api/#get_user_to_login","text":"","title":"get_user_to_login"},{"location":"api/#user_registered","text":"","title":"user_registered"},{"location":"api/#user_verified","text":"","title":"user_verified"},{"location":"api/#captchatype","text":"","title":"CaptchaType"},{"location":"api/#g_user","text":"","title":"g_user"},{"location":"api/#get_payload_from_token","text":"","title":"get_payload_from_token"},{"location":"api/#inject_fields","text":"","title":"inject_fields"},{"location":"api/#revoke_user_refresh_token","text":"","title":"revoke_user_refresh_token"},{"location":"api/#usermodel","text":"","title":"UserModel"},{"location":"api/#captcha","text":"class Captcha () Creates a brand-new captcha. Returns a base64 encoded string of the captcha. And uuid representing the captcha id in the database. When you will try to log in or register You will need submit that uuid With the user input. The captcha will be invoked when the timeout expires .","title":"Captcha"},{"location":"api/#field","text":"@strawberry . mutation ( description = __doc__ ) def field () -> CaptchaType","title":"field"},{"location":"api/#afield","text":"@strawberry . mutation ( description = __doc__ ) @sync_to_async def afield () -> CaptchaType","title":"afield"},{"location":"api/#check_captcha","text":"def check_captcha ( input_ : Union [ \"RegisterMixin.RegisterInput\" , \"ObtainJSONWebTokenMixin.ObtainJSONWebTokenInput\" ])","title":"check_captcha"},{"location":"api/#registermixin","text":"class RegisterMixin () Register user with fields defined in the settings. If the email field of the user model is part of the registration fields (default), check if there is no user with that email or as a secondary email. If it exists, it does not register the user, even if the email field is not defined as unique (default of the default django user model). When creating the user, it also creates a UserStatus related to that user, making it possible to track if the user is archived, verified and has a secondary email. Send account verification email. If allowed to not verified users login, return token.","title":"RegisterMixin"},{"location":"api/#registerinput","text":"@strawberry . input @inject_fields ( app_settings . REGISTER_MUTATION_FIELDS ) class RegisterInput ()","title":"RegisterInput"},{"location":"api/#form","text":"","title":"form"},{"location":"api/#resolve_mutation","text":"@classmethod def resolve_mutation ( cls , info , input_ : RegisterInput ) -> MutationNormalOutput","title":"resolve_mutation"},{"location":"api/#verifyaccountmixin","text":"class VerifyAccountMixin () Verify user account. Receive the token that was sent by email. If the token is valid, make the user verified by making the user.status.verified field true.","title":"VerifyAccountMixin"},{"location":"api/#verifyaccountinput","text":"@strawberry . input class VerifyAccountInput ()","title":"VerifyAccountInput"},{"location":"api/#token","text":"","title":"token"},{"location":"api/#resolve_mutation_1","text":"@classmethod def resolve_mutation ( cls , info : Info , input_ : VerifyAccountInput ) -> MutationNormalOutput","title":"resolve_mutation"},{"location":"api/#verifysecondaryemailmixin","text":"class VerifySecondaryEmailMixin () Verify user secondary email. Receive the token that was sent by email. User is already verified when using this mutation. If the token is valid, add the secondary email to user.status.secondary_email field. Note that until the secondary email is verified, it has not been saved anywhere beyond the token, so it can still be used to create a new account. After being verified, it will no longer be available.","title":"VerifySecondaryEmailMixin"},{"location":"api/#verifysecondaryemailinput","text":"@strawberry . input class VerifySecondaryEmailInput ()","title":"VerifySecondaryEmailInput"},{"location":"api/#token_1","text":"","title":"token"},{"location":"api/#resolve_mutation_2","text":"@classmethod def resolve_mutation ( cls , _ , input_ : VerifySecondaryEmailInput ) -> MutationNormalOutput","title":"resolve_mutation"},{"location":"api/#resendactivationemailmixin","text":"class ResendActivationEmailMixin () Sends activation email. It is called resend because theoretically the first activation email was sent when the user registered. If there is no user with the requested email, a successful response is returned.","title":"ResendActivationEmailMixin"},{"location":"api/#resendactivationemailinput","text":"@strawberry . input class ResendActivationEmailInput ()","title":"ResendActivationEmailInput"},{"location":"api/#email","text":"","title":"email"},{"location":"api/#resolve_mutation_3","text":"@classmethod def resolve_mutation ( cls , info , input_ : ResendActivationEmailInput ) -> MutationNormalOutput","title":"resolve_mutation"},{"location":"api/#sendpasswordresetemailmixin","text":"class SendPasswordResetEmailMixin () Send password reset email. For non verified users, send an activation email instead. Accepts both primary and secondary email. If there is no user with the requested email, a successful response is returned.","title":"SendPasswordResetEmailMixin"},{"location":"api/#sendpasswordresetemailinput","text":"@strawberry . input class SendPasswordResetEmailInput ()","title":"SendPasswordResetEmailInput"},{"location":"api/#email_1","text":"","title":"email"},{"location":"api/#resolve_mutation_4","text":"@classmethod def resolve_mutation ( cls , info , input_ : SendPasswordResetEmailInput ) -> MutationNormalOutput","title":"resolve_mutation"},{"location":"api/#passwordresetmixin","text":"class PasswordResetMixin () Change user password without old password. Receive the token that was sent by email. If token and new passwords are valid, update user password and in case of using refresh tokens, revoke all of them. Also, if user has not been verified yet, verify it.","title":"PasswordResetMixin"},{"location":"api/#passwordresetinput","text":"@strawberry . input class PasswordResetInput ()","title":"PasswordResetInput"},{"location":"api/#token_2","text":"","title":"token"},{"location":"api/#new_password1","text":"","title":"new_password1"},{"location":"api/#new_password2","text":"","title":"new_password2"},{"location":"api/#form_1","text":"","title":"form"},{"location":"api/#resolve_mutation_5","text":"@classmethod def resolve_mutation ( cls , _ , input_ : PasswordResetInput ) -> MutationNormalOutput","title":"resolve_mutation"},{"location":"api/#passwordsetmixin","text":"class PasswordSetMixin () Set user password - for password-less registration Receive the token that was sent by email. If token and new passwords are valid, set user password and in case of using refresh tokens, revoke all of them. Also, if user has not been verified yet, verify it.","title":"PasswordSetMixin"},{"location":"api/#passwordsetinput","text":"@strawberry . input class PasswordSetInput ()","title":"PasswordSetInput"},{"location":"api/#token_3","text":"","title":"token"},{"location":"api/#new_password1_1","text":"","title":"new_password1"},{"location":"api/#new_password2_1","text":"","title":"new_password2"},{"location":"api/#form_2","text":"","title":"form"},{"location":"api/#resolve_mutation_6","text":"@classmethod def resolve_mutation ( cls , _ , input_ : PasswordSetInput ) -> MutationNormalOutput","title":"resolve_mutation"},{"location":"api/#obtainjsonwebtokenmixin","text":"class ObtainJSONWebTokenMixin () Obtain JSON web token for given user. Allow to perform login with different fields, and secondary email if set. The fields are defined on settings. Not verified users can log in by default. This can be changes on settings. If user is archived, make it unarchived and return unarchiving=True on OutputBase.","title":"ObtainJSONWebTokenMixin"},{"location":"api/#obtainjsonwebtokeninput","text":"@strawberry . input @inject_fields ( app_settings . LOGIN_FIELDS ) class ObtainJSONWebTokenInput ()","title":"ObtainJSONWebTokenInput"},{"location":"api/#password","text":"","title":"password"},{"location":"api/#resolve_mutation_7","text":"@classmethod def resolve_mutation ( cls , info , input_ : ObtainJSONWebTokenInput ) -> ObtainJSONWebTokenPayload","title":"resolve_mutation"},{"location":"api/#archiveordeletemixin","text":"class ArchiveOrDeleteMixin ()","title":"ArchiveOrDeleteMixin"},{"location":"api/#archiveordeletemixininput","text":"@strawberry . input class ArchiveOrDeleteMixinInput ()","title":"ArchiveOrDeleteMixinInput"},{"location":"api/#password_1","text":"","title":"password"},{"location":"api/#resolve_mutation_8","text":"@classmethod @verification_required @_password_confirmation_required def resolve_mutation ( cls , info , input_ : ArchiveOrDeleteMixinInput ) -> MutationNormalOutput","title":"resolve_mutation"},{"location":"api/#archiveaccountmixin","text":"class ArchiveAccountMixin ( ArchiveOrDeleteMixin ) Archive account and revoke refresh tokens. User must be verified and confirm password.","title":"ArchiveAccountMixin"},{"location":"api/#resolve_action","text":"@classmethod def resolve_action ( cls , user )","title":"resolve_action"},{"location":"api/#deleteaccountmixin","text":"class DeleteAccountMixin ( ArchiveOrDeleteMixin ) Delete account permanently or make user.is_active=False . The behavior is defined on settings. Anyway user refresh tokens are revoked. User must be verified and confirm password.","title":"DeleteAccountMixin"},{"location":"api/#resolve_action_1","text":"@classmethod def resolve_action ( cls , user )","title":"resolve_action"},{"location":"api/#passwordchangemixin","text":"class PasswordChangeMixin () Change account password when user knows the old password. A new token and refresh token are sent. User must be verified.","title":"PasswordChangeMixin"},{"location":"api/#passwordchangeinput","text":"@strawberry . input class PasswordChangeInput ()","title":"PasswordChangeInput"},{"location":"api/#old_password","text":"","title":"old_password"},{"location":"api/#new_password1_2","text":"","title":"new_password1"},{"location":"api/#new_password2_2","text":"","title":"new_password2"},{"location":"api/#form_3","text":"","title":"form"},{"location":"api/#resolve_mutation_9","text":"@classmethod @verification_required @_password_confirmation_required def resolve_mutation ( cls , info : Info , input_ : PasswordChangeInput ) -> ObtainJSONWebTokenPayload","title":"resolve_mutation"},{"location":"api/#updateaccountmixin","text":"class UpdateAccountMixin () Update user model fields, defined on settings. User must be verified.","title":"UpdateAccountMixin"},{"location":"api/#updateaccountinput","text":"@strawberry . input @inject_fields ( app_settings . UPDATE_MUTATION_FIELDS ) class UpdateAccountInput ()","title":"UpdateAccountInput"},{"location":"api/#form_4","text":"","title":"form"},{"location":"api/#resolve_mutation_10","text":"@classmethod @verification_required def resolve_mutation ( cls , info , input_ : UpdateAccountInput ) -> MutationNormalOutput","title":"resolve_mutation"},{"location":"api/#verifytokenmixin","text":"class VerifyTokenMixin () Checks if a token is not expired and correct","title":"VerifyTokenMixin"},{"location":"api/#verifytokeninput","text":"@strawberry . input class VerifyTokenInput ()","title":"VerifyTokenInput"},{"location":"api/#token_4","text":"","title":"token"},{"location":"api/#resolve_mutation_11","text":"@classmethod def resolve_mutation ( cls , info , input_ : VerifyTokenInput ) -> VerifyTokenPayload","title":"resolve_mutation"},{"location":"api/#refreshtokenmixin","text":"class RefreshTokenMixin ()","title":"RefreshTokenMixin"},{"location":"api/#refreshtoken-to-refresh-your-token","text":"using the refresh token you already got during authorization. this will obtain a brand-new token (and possibly a refresh token) with renewed expiration time for non-expired tokens","title":"refreshToken to refresh your token:"},{"location":"api/#refreshtokeninput","text":"@strawberry . input class RefreshTokenInput ()","title":"RefreshTokenInput"},{"location":"api/#refresh_token","text":"","title":"refresh_token"},{"location":"api/#resolve_mutation_12","text":"@classmethod def resolve_mutation ( cls , info , input_ : RefreshTokenInput ) -> RefreshTokenPayload","title":"resolve_mutation"},{"location":"api/#revoketokenmixin","text":"class RevokeTokenMixin () Suspends a refresh token","title":"RevokeTokenMixin"},{"location":"api/#revoketokeninput","text":"@strawberry . input class RevokeTokenInput ()","title":"RevokeTokenInput"},{"location":"api/#refresh_token_1","text":"","title":"refresh_token"},{"location":"api/#resolve_mutation_13","text":"@classmethod def resolve_mutation ( cls , info , input_ : RevokeTokenInput ) -> RevokeTokenPayload","title":"resolve_mutation"},{"location":"api/#sendsecondaryemailactivationmixin","text":"class SendSecondaryEmailActivationMixin () Send activation to secondary email. User must be verified and confirm password.","title":"SendSecondaryEmailActivationMixin"},{"location":"api/#sendsecondaryemailactivationinput","text":"@strawberry . input class SendSecondaryEmailActivationInput ()","title":"SendSecondaryEmailActivationInput"},{"location":"api/#password_2","text":"","title":"password"},{"location":"api/#resolve_mutation_14","text":"@classmethod @verification_required @_password_confirmation_required def resolve_mutation ( cls , info , input_ : SendSecondaryEmailActivationInput ) -> MutationNormalOutput","title":"resolve_mutation"},{"location":"api/#swapemailsmixin","text":"class SwapEmailsMixin () Swap between primary and secondary emails. Require password confirmation.","title":"SwapEmailsMixin"},{"location":"api/#swapemailsinput","text":"@strawberry . input class SwapEmailsInput ()","title":"SwapEmailsInput"},{"location":"api/#password_3","text":"","title":"password"},{"location":"api/#resolve_mutation_15","text":"@classmethod @secondary_email_required def resolve_mutation ( cls , info : Info , input_ : SwapEmailsInput ) -> MutationNormalOutput","title":"resolve_mutation"},{"location":"api/#removesecondaryemailmixin","text":"class RemoveSecondaryEmailMixin () Remove user secondary email. Require password confirmation.","title":"RemoveSecondaryEmailMixin"},{"location":"api/#removesecondaryemailinput","text":"@strawberry . input class RemoveSecondaryEmailInput ()","title":"RemoveSecondaryEmailInput"},{"location":"api/#password_4","text":"","title":"password"},{"location":"api/#resolve_mutation_16","text":"@classmethod @secondary_email_required @_password_confirmation_required def resolve_mutation ( cls , info : Info , input_ : RemoveSecondaryEmailInput ) -> MutationNormalOutput","title":"resolve_mutation"},{"location":"captcha/","text":"Captcha \u00b6 this package provides a fully functional captcha validation system the default setting are: \"LOGIN_REQUIRE_CAPTCHA\" : True , \"REGISTER_REQUIRE_CAPTCHA\" : True , if you don't like this set them to False. The Captcha is available to query via a base64 encoded string or via a static .png image. Note: The Image is in PNG format base64 static mutation MyMutation { captcha { uuid pilImage } } You will further be needed to implement a translation in the UI. For the creation of a static set CAPTCHA_SAVE_IMAGE = True on your settings. This will use django's Imagefield to store the captcha image. You will also be needed to include a path in your urlpatterns for development, as per the documentation . mutation MyMutation { captcha { uuid image{ width height url } } }","title":"Captcha"},{"location":"captcha/#captcha","text":"this package provides a fully functional captcha validation system the default setting are: \"LOGIN_REQUIRE_CAPTCHA\" : True , \"REGISTER_REQUIRE_CAPTCHA\" : True , if you don't like this set them to False. The Captcha is available to query via a base64 encoded string or via a static .png image. Note: The Image is in PNG format base64 static mutation MyMutation { captcha { uuid pilImage } } You will further be needed to implement a translation in the UI. For the creation of a static set CAPTCHA_SAVE_IMAGE = True on your settings. This will use django's Imagefield to store the captcha image. You will also be needed to include a path in your urlpatterns for development, as per the documentation . mutation MyMutation { captcha { uuid image{ width height url } } }","title":"Captcha"},{"location":"changelog/","text":"Changelog \u00b6 v0.3.4.1 \u00b6 deprecations \u00b6 LOGIN_REQUIRED_FIELDS and LOGIN_OPTIONAL_FIELDS are deprecated in favor of LOGIN_FIELDS . From now on you should pass StrawberryField instance to LOGIN_FIELDS and it is absolutely your responsibility what would be optional/required. REGISTER_MUTATION_FIELDS_OPTIONAL is deprecated in favor of REGISTER_MUTATION_FIELDS . UPDATE_MUTATION_FIELDS , REGISTER_MUTATION_FIELDS are also taking StrawberryField instances from now on. v0.3.4.0 \u00b6 New features serve Captcha over static files. New setting introduced, CAPTCHA_SAVE_IMAGE: bool = False . v0.3.3.2 \u00b6 New features Any fields that are in either UPDATE_MUTATION_FIELDS , REGISTER_MUTATION_FIELDS , REGISTER_MUTATION_FIELDS_OPTIONAL And the pk field of the model. Will be inserted to UserType and will be in user queries. Doc strings in gqlquth_settings object Bug fixed Issue #45, #42 LOGIN_REQUIRED_FIELDS is now supported,\\ These fields would be used to authenticate with SD-jwt authenticate function. This function will call each of our AUTHENTICATION_BACKENDS , And will return the user from one of them unless PermissionDenied was raised. REGISTER_MUTATION_FIELDS is now supported,\\ Fields that will be registered there will be required by Register mutation Development Notes Added new marker for pytest, default_user this is the user defined in the default settings, And the custom user is in settings_b.py with no email field. v0.3.3.1 - pre-release \u00b6 New features async support using ASGI, the resolvers are still sync because of django's ORM - API changes Previously, following the graphene version, we did i.e token_auth = relay.ObtainJSONWebToken.Field ,\\ In order to respect pep8 (since it is a function)\\ and Strawberry style we changed it to token_auth = relay.ObtainJSONWebToken.field . Renamed Cap.Field to Captcha.field . Deprecations Removed setting ASYNC_EMAIL_TASK, (originally this was a celery task). Development Notes Major refactoring of how the test work: removed all the dicts that was flying around and used dataclasses. added async tests for all tests. no longer using request factory, now using test client as it emulates more real life environment. v0.3.16 \u00b6 Nothing new, adding PyJWT<=2.0.0 to requirements v0.3.15 \u00b6 Emit user_verified signal on password reset (thanks to @imsheldon ) v0.3.14 \u00b6 Add passwordless registration (thanks to @joshuachinemezu ) Add user_verified and user_registered signals (thanks to @mnieber ) Verify user in password reset mutation (thanks to capaci ) v0.3.13 \u00b6 Add EMAIL_TEMPLATE_VARIABLES setting (thanks to capaci ) v0.3.12 \u00b6 Add CUSTOM_ERROR_TYPE setting (thanks to boolangery ) v0.3.11 \u00b6 Add select_related to UserNode to limit db queries (thanks to maxpeterson ) v0.3.10 \u00b6 Pseudo async email support (thanks to bzhr and me ) v0.3.9 \u00b6 Prevents that UserNode is registered globally for the User type (thanks to panosangelopoulos ) v0.3.8 \u00b6 Add request and timestamp to email templates (thanks to yanivtoledano ) v0.3.7 \u00b6 Add template variables to email subjects. v0.3.6 \u00b6 Replace RemovedInDjango40Warning ugettext with gettext (thanks to ulgens ) v0.3.5 \u00b6 Added MeQuery (thanks to pors ). v0.3.4 \u00b6 Renamed from ErrorType to ExpectedErrorType , preventing clash with a strawberry.django type with same name.. v0.3.3 \u00b6 Fixed bug when performing login in PasswordChangeMixin (thanks to panosangelopoulos ). v0.3.2 \u00b6 Fixed typo in error code/message for expired_token (thanks to yanivtoledano ). v0.3.1 \u00b6 add pk to UserNode. v0.3.0 \u00b6 release beta. v0.2 \u00b6 v0.2.8 \u00b6 return new token and refreshToken on password change. v0.2.7 \u00b6 allow login on register, returning token and refresh token. v0.2.6 \u00b6 review error fields in some mutations. v0.2.5 \u00b6 update apps config. nothing new. v0.2.4 \u00b6 add mutation to remove secondary email. v0.2.3 \u00b6 user status is created on signal. v0.2.2 \u00b6 fix typo in setup. nothing new. v0.2.1 \u00b6 fix readme on pypi. nothing new. v0.2.0 \u00b6 minor bug fixes. add user status model to track if user is archived, verified and secondary email. add new mutations to handle secondary email. allow login with secondary email. v0.1 \u00b6 0.1.11 \u00b6 Fix minor bugs. 0.1.10 \u00b6 Fix minor bugs. 0.1.9 \u00b6 Rename settings params. 0.1.8 \u00b6 Fix typo in settings. 0.1.7 \u00b6 No changes (testing release on Travis). 0.1.6 \u00b6 Support for Django >= 2.1 0.1.5 \u00b6 Revoke refresh tokens when archiving user. 0.1.4 \u00b6 Allow to revoke refresh tokens on password change and reset. 0.1.3 \u00b6 Better settings api. 0.1.2 \u00b6 Update setup.py. 0.1.1 \u00b6 Add initial README file! 0.1.0 \u00b6 Hello world!","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#v0341","text":"","title":"v0.3.4.1"},{"location":"changelog/#deprecations","text":"LOGIN_REQUIRED_FIELDS and LOGIN_OPTIONAL_FIELDS are deprecated in favor of LOGIN_FIELDS . From now on you should pass StrawberryField instance to LOGIN_FIELDS and it is absolutely your responsibility what would be optional/required. REGISTER_MUTATION_FIELDS_OPTIONAL is deprecated in favor of REGISTER_MUTATION_FIELDS . UPDATE_MUTATION_FIELDS , REGISTER_MUTATION_FIELDS are also taking StrawberryField instances from now on.","title":"deprecations"},{"location":"changelog/#v0340","text":"New features serve Captcha over static files. New setting introduced, CAPTCHA_SAVE_IMAGE: bool = False .","title":"v0.3.4.0"},{"location":"changelog/#v0332","text":"New features Any fields that are in either UPDATE_MUTATION_FIELDS , REGISTER_MUTATION_FIELDS , REGISTER_MUTATION_FIELDS_OPTIONAL And the pk field of the model. Will be inserted to UserType and will be in user queries. Doc strings in gqlquth_settings object Bug fixed Issue #45, #42 LOGIN_REQUIRED_FIELDS is now supported,\\ These fields would be used to authenticate with SD-jwt authenticate function. This function will call each of our AUTHENTICATION_BACKENDS , And will return the user from one of them unless PermissionDenied was raised. REGISTER_MUTATION_FIELDS is now supported,\\ Fields that will be registered there will be required by Register mutation Development Notes Added new marker for pytest, default_user this is the user defined in the default settings, And the custom user is in settings_b.py with no email field.","title":"v0.3.3.2"},{"location":"changelog/#v0331-pre-release","text":"New features async support using ASGI, the resolvers are still sync because of django's ORM - API changes Previously, following the graphene version, we did i.e token_auth = relay.ObtainJSONWebToken.Field ,\\ In order to respect pep8 (since it is a function)\\ and Strawberry style we changed it to token_auth = relay.ObtainJSONWebToken.field . Renamed Cap.Field to Captcha.field . Deprecations Removed setting ASYNC_EMAIL_TASK, (originally this was a celery task). Development Notes Major refactoring of how the test work: removed all the dicts that was flying around and used dataclasses. added async tests for all tests. no longer using request factory, now using test client as it emulates more real life environment.","title":"v0.3.3.1 - pre-release"},{"location":"changelog/#v0316","text":"Nothing new, adding PyJWT<=2.0.0 to requirements","title":"v0.3.16"},{"location":"changelog/#v0315","text":"Emit user_verified signal on password reset (thanks to @imsheldon )","title":"v0.3.15"},{"location":"changelog/#v0314","text":"Add passwordless registration (thanks to @joshuachinemezu ) Add user_verified and user_registered signals (thanks to @mnieber ) Verify user in password reset mutation (thanks to capaci )","title":"v0.3.14"},{"location":"changelog/#v0313","text":"Add EMAIL_TEMPLATE_VARIABLES setting (thanks to capaci )","title":"v0.3.13"},{"location":"changelog/#v0312","text":"Add CUSTOM_ERROR_TYPE setting (thanks to boolangery )","title":"v0.3.12"},{"location":"changelog/#v0311","text":"Add select_related to UserNode to limit db queries (thanks to maxpeterson )","title":"v0.3.11"},{"location":"changelog/#v0310","text":"Pseudo async email support (thanks to bzhr and me )","title":"v0.3.10"},{"location":"changelog/#v039","text":"Prevents that UserNode is registered globally for the User type (thanks to panosangelopoulos )","title":"v0.3.9"},{"location":"changelog/#v038","text":"Add request and timestamp to email templates (thanks to yanivtoledano )","title":"v0.3.8"},{"location":"changelog/#v037","text":"Add template variables to email subjects.","title":"v0.3.7"},{"location":"changelog/#v036","text":"Replace RemovedInDjango40Warning ugettext with gettext (thanks to ulgens )","title":"v0.3.6"},{"location":"changelog/#v035","text":"Added MeQuery (thanks to pors ).","title":"v0.3.5"},{"location":"changelog/#v034","text":"Renamed from ErrorType to ExpectedErrorType , preventing clash with a strawberry.django type with same name..","title":"v0.3.4"},{"location":"changelog/#v033","text":"Fixed bug when performing login in PasswordChangeMixin (thanks to panosangelopoulos ).","title":"v0.3.3"},{"location":"changelog/#v032","text":"Fixed typo in error code/message for expired_token (thanks to yanivtoledano ).","title":"v0.3.2"},{"location":"changelog/#v031","text":"add pk to UserNode.","title":"v0.3.1"},{"location":"changelog/#v030","text":"release beta.","title":"v0.3.0"},{"location":"changelog/#v02","text":"","title":"v0.2"},{"location":"changelog/#v028","text":"return new token and refreshToken on password change.","title":"v0.2.8"},{"location":"changelog/#v027","text":"allow login on register, returning token and refresh token.","title":"v0.2.7"},{"location":"changelog/#v026","text":"review error fields in some mutations.","title":"v0.2.6"},{"location":"changelog/#v025","text":"update apps config. nothing new.","title":"v0.2.5"},{"location":"changelog/#v024","text":"add mutation to remove secondary email.","title":"v0.2.4"},{"location":"changelog/#v023","text":"user status is created on signal.","title":"v0.2.3"},{"location":"changelog/#v022","text":"fix typo in setup. nothing new.","title":"v0.2.2"},{"location":"changelog/#v021","text":"fix readme on pypi. nothing new.","title":"v0.2.1"},{"location":"changelog/#v020","text":"minor bug fixes. add user status model to track if user is archived, verified and secondary email. add new mutations to handle secondary email. allow login with secondary email.","title":"v0.2.0"},{"location":"changelog/#v01","text":"","title":"v0.1"},{"location":"changelog/#0111","text":"Fix minor bugs.","title":"0.1.11"},{"location":"changelog/#0110","text":"Fix minor bugs.","title":"0.1.10"},{"location":"changelog/#019","text":"Rename settings params.","title":"0.1.9"},{"location":"changelog/#018","text":"Fix typo in settings.","title":"0.1.8"},{"location":"changelog/#017","text":"No changes (testing release on Travis).","title":"0.1.7"},{"location":"changelog/#016","text":"Support for Django >= 2.1","title":"0.1.6"},{"location":"changelog/#015","text":"Revoke refresh tokens when archiving user.","title":"0.1.5"},{"location":"changelog/#014","text":"Allow to revoke refresh tokens on password change and reset.","title":"0.1.4"},{"location":"changelog/#013","text":"Better settings api.","title":"0.1.3"},{"location":"changelog/#012","text":"Update setup.py.","title":"0.1.2"},{"location":"changelog/#011","text":"Add initial README file!","title":"0.1.1"},{"location":"changelog/#010","text":"Hello world!","title":"0.1.0"},{"location":"community/","text":"Community \u00b6 Useful links \u00b6 Links strawberry strawberry docs strawberry-django-jwt (forked from graphene) graphene django-gql-auth(where this project forked from) Django GraphQL JWT Graphene Django Similar projects \u00b6 Django GraphQL Social Auth Django Rest Auth (REST) Djoser (REST) Tutorials \u00b6 Have a tutorial or lesson to share? Open a PR and link it here!","title":"Community"},{"location":"community/#community","text":"","title":"Community"},{"location":"community/#useful-links","text":"Links strawberry strawberry docs strawberry-django-jwt (forked from graphene) graphene django-gql-auth(where this project forked from) Django GraphQL JWT Graphene Django","title":"Useful links"},{"location":"community/#similar-projects","text":"Django GraphQL Social Auth Django Rest Auth (REST) Djoser (REST)","title":"Similar projects"},{"location":"community/#tutorials","text":"Have a tutorial or lesson to share? Open a PR and link it here!","title":"Tutorials"},{"location":"contributing/","text":"Contributing \u00b6 Thanks for helping improve Django GraphQL Auth! All kinds of contributions are welcome: Bug fixes Documentation improvements New features Refactoring Fix some typo Write more tests Getting started \u00b6 If you have a specific contribution in mind, be sure to check the issues and projects in progress - someone could already be working on something similar and you can help out. Project setup \u00b6 After cloning this repo, ensure dependencies are installed by running: make dev-setup and pip install tox Running tests \u00b6 After developing, you can run tests with: # python=3.7 and django=3.0 make test You can specify versions, for the full list see the tox.ini file. # python=3.6 and django=2.2 make test p = 36 d = 22 Test directly with tox: tox Single file test shortcut: # run only tests in tests/test_register.py make test-file f = register For live testing on a django project, you can use the testproject. Create a different virtualenv, install the dependencies again and run: cd testproject make install-local v = <CURRENT VERSION IN gqlauth.__init__> Opening Pull Requests \u00b6 Please fork the project and open a pull request against the master branch. This will trigger a series of tests and lint checks. We advise that you format and run lint locally before doing this to save time: make format make lint Documentation \u00b6 The documentation is generated using the excellent MkDocs with material theme . The documentation dependencies are installed by running: pip install -r docs/requirements.txt Then to produce a HTML version of the documentation, for live editing: make serve It will run the docs/pre_build.py script before building the docs.","title":"Contributing"},{"location":"contributing/#contributing","text":"Thanks for helping improve Django GraphQL Auth! All kinds of contributions are welcome: Bug fixes Documentation improvements New features Refactoring Fix some typo Write more tests","title":"Contributing"},{"location":"contributing/#getting-started","text":"If you have a specific contribution in mind, be sure to check the issues and projects in progress - someone could already be working on something similar and you can help out.","title":"Getting started"},{"location":"contributing/#project-setup","text":"After cloning this repo, ensure dependencies are installed by running: make dev-setup and pip install tox","title":"Project setup"},{"location":"contributing/#running-tests","text":"After developing, you can run tests with: # python=3.7 and django=3.0 make test You can specify versions, for the full list see the tox.ini file. # python=3.6 and django=2.2 make test p = 36 d = 22 Test directly with tox: tox Single file test shortcut: # run only tests in tests/test_register.py make test-file f = register For live testing on a django project, you can use the testproject. Create a different virtualenv, install the dependencies again and run: cd testproject make install-local v = <CURRENT VERSION IN gqlauth.__init__>","title":"Running tests"},{"location":"contributing/#opening-pull-requests","text":"Please fork the project and open a pull request against the master branch. This will trigger a series of tests and lint checks. We advise that you format and run lint locally before doing this to save time: make format make lint","title":"Opening Pull Requests"},{"location":"contributing/#documentation","text":"The documentation is generated using the excellent MkDocs with material theme . The documentation dependencies are installed by running: pip install -r docs/requirements.txt Then to produce a HTML version of the documentation, for live editing: make serve It will run the docs/pre_build.py script before building the docs.","title":"Documentation"},{"location":"contributors/","text":"Contributors \u00b6 @pedrobern @nrbnlulu @yanivtoledano @ulgens @panosangelopoulos @pors @bzhr @maxpeterson @boolangery @capaci @mnieber @joshuachinemezu @imsheldon","title":"Contributors"},{"location":"contributors/#contributors","text":"@pedrobern @nrbnlulu @yanivtoledano @ulgens @panosangelopoulos @pors @bzhr @maxpeterson @boolangery @capaci @mnieber @joshuachinemezu @imsheldon","title":"Contributors"},{"location":"decorators/","text":"auto generated using pydoc_markdown wraps \u00b6 Info \u00b6 g_info \u00b6 g_user \u00b6 MutationNormalOutput \u00b6 Messages \u00b6 PermissionDenied \u00b6 login_required \u00b6 def login_required ( fn ) If the user is registered verification_required \u00b6 def verification_required ( fn ) if the user was approved secondary_email_required \u00b6 def secondary_email_required ( fn ) _password_confirmation_required \u00b6 def _password_confirmation_required ( fn ) not to be used publicly. allowed_permissions \u00b6 def allowed_permissions ( roles : list ) checks a list of roles if it applies to a user verification required by default.","title":"Decorators"},{"location":"decorators/#wraps","text":"","title":"wraps"},{"location":"decorators/#info","text":"","title":"Info"},{"location":"decorators/#g_info","text":"","title":"g_info"},{"location":"decorators/#g_user","text":"","title":"g_user"},{"location":"decorators/#mutationnormaloutput","text":"","title":"MutationNormalOutput"},{"location":"decorators/#messages","text":"","title":"Messages"},{"location":"decorators/#permissiondenied","text":"","title":"PermissionDenied"},{"location":"decorators/#login_required","text":"def login_required ( fn ) If the user is registered","title":"login_required"},{"location":"decorators/#verification_required","text":"def verification_required ( fn ) if the user was approved","title":"verification_required"},{"location":"decorators/#secondary_email_required","text":"def secondary_email_required ( fn )","title":"secondary_email_required"},{"location":"decorators/#_password_confirmation_required","text":"def _password_confirmation_required ( fn ) not to be used publicly.","title":"_password_confirmation_required"},{"location":"decorators/#allowed_permissions","text":"def allowed_permissions ( roles : list ) checks a list of roles if it applies to a user verification required by default.","title":"allowed_permissions"},{"location":"installation/","text":"Installation \u00b6 Attention If you are not familiarized with Strawberry or Strawberry Django JWT , skip this installation section and go to the quickstart guide. Requirements \u00b6 Python: 3.10 Django: 4.0 Installation \u00b6 pip install strawberry-django-auth For those that are not installed, this will automatically install strawberry , strawberry-django , strawberry-django-jwt , django . Add gqlauth to installed apps. INSTALLED_APPS = [ # ... \"gqlauth\" ] Migrate: python manage.py migrate Setup \u00b6 The following are the minimum steps required to get it running. It should not take more than 10 minutes. 1. Schema \u00b6 In your schema add the following: \u00b6 Schema # yourapp/users/schema.py import strawberry from gqlauth.user.queries import UserQueries GraphQl Relay from gqlauth.user import arg_mutations @strawberry . type class UserMutations : token_auth = arg_mutations . ObtainJSONWebToken . field # login mutation verify_token = arg_mutations . VerifyToken . field refresh_token = arg_mutations . RefreshToken . field revoke_token = arg_mutations . RevokeToken . field register = arg_mutations . Register . field verify_account = arg_mutations . VerifyAccount . field update_account = arg_mutations . UpdateAccount . field resend_activation_email = arg_mutations . ResendActivationEmail . field archive_account = arg_mutations . ArchiveAccount . field delete_account = arg_mutations . DeleteAccount . field password_change = arg_mutations . PasswordChange . field send_password_reset_email = arg_mutations . SendPasswordResetEmail . field password_reset = arg_mutations . PasswordReset . field password_set = arg_mutations . PasswordSet . field verify_secondary_email = arg_mutations . VerifySecondaryEmail . field swap_emails = arg_mutations . SwapEmails . field remove_secondary_email = arg_mutations . RemoveSecondaryEmail . field send_secondary_email_activation = arg_mutations . SendSecondaryEmailActivation . field from gqlauth.user import relay @strawberry . type class UserMutations : token_auth = relay . ObtainJSONWebToken . field # login mutation verify_token = relay . VerifyToken . field refresh_token = relay . RefreshToken . field revoke_token = relay . RevokeToken . field register = relay . Register . field verify_account = relay . VerifyAccount . field update_account = relay . UpdateAccount . field resend_activation_email = relay . ResendActivationEmail . field archive_account = relay . ArchiveAccount . field delete_account = relay . DeleteAccount . field password_change = relay . PasswordChange . field send_password_reset_email = relay . SendPasswordResetEmail . field password_reset = relay . PasswordReset . field password_set = relay . PasswordSet . field verify_secondary_email = relay . VerifySecondaryEmail . field swap_emails = relay . SwapEmails . field remove_secondary_email = relay . RemoveSecondaryEmail . field send_secondary_email_activation = relay . SendSecondaryEmailActivation . field # yourapp/schema.py import strawberry from strawberry.tools import merge_types from users.schema import UserMutations , UserQueries Query = merge_types ( \"RootQuery\" , ( UserQueries ,)) Mutation = merge_types ( \"RootMutation\" , ( UserMutations ,)) schema = strawberry . Schema ( query = Query , mutation = Mutation ) 2. Allow Any Classes \u00b6 Please refer to strawberry-django-jwt . as it is not trivially possible with strawberry. 3. Authentication Backend - optional \u00b6 Add the following to your AUTHENTICATION_BACKENDS : AUTHENTICATION_BACKENDS = [ # remove this # \"strawberry_django_jwt.backends.JSONWebTokenBackend\", # add this \"gqlauth.backends.GraphQLAuthBackend\" , # ... ] What's the difference from the strawberry_django_jwt.backend? We implement the same backend with only one difference: It will not raise if you send a request with bad token to a class that is not on JWT_ALLOW_ANY_CLASSES . Why should I want this behaivor? Instead of raising an actual error, we can handle it and return whatever make sense, e.g.: cls ( success = False errors = \"Unauthenticated.\" ) You should handle this situation doing one of the following: Simply use the strawberry_django_jwt decorator @login_required . Use our login_required decorator , note that this expect your output to contain this output . Create your own login_required decorator! 4. Refresh Token - optional \u00b6 Explanation Refresh tokens are concept of jwt-web-tokens what they mean is that every x time a so called logged user will need to request for a new token from the server and generally there are two types of them: Single token refresh (and that's the default) Long running refresh tokens Single token refresh Long running refresh tokens they will require the user to ask for refresh token every 5 minutes Warning most importantly won't use the database therefore it is not state-less for more information head to Django GraphQL JWT they will require the database (threfore migration) are state-less you should probably follow Django GraphQL JWT docs for more information docs :wink: but here is a TL;DR: to set this up: INSTALLED_APPS = [ # ... \"strawberry_django_jwt.refresh_token\" , ] GRAPHQL_JWT = { # ... \"JWT_VERIFY_EXPIRATION\" : True , \"JWT_LONG_RUNNING_REFRESH_TOKEN\" : True , \"JWT_EXPIRATION_DELTA\" : timedelta ( minutes = 5 ), \"JWT_REFRESH_EXPIRATION_DELTA\" : timedelta ( days = 7 ), } And remember to migrate: python -m manage migrate 5. Email Templates \u00b6 Overriding email templates is covered here . This package comes with some default email templates, if you plan to use it, make sure your templates configuration has the following: TEMPLATES = [ { # ... 'APP_DIRS' : True , }, ] 6. Email Backend \u00b6 The default configuration is to send activation email, you can set it to False on your settings , but you still need an Email Backend to password reset. The quickest way for development is to setup a Console Email Backend , simply add the following to your settings.py . EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend' Now all emails are sent to the standard output, instead of an actual email. 7. Overriding settings \u00b6 let's disable captcha validation. in your settings.py add the following: # settings.py from gqlauth.settings_type import GqlAuthSettings GQL_AUTH = GqlAuthSettings ( LOGIN_REQUIRE_CAPTHA = False , REGISTER_REQUIRE_CAPTCHA = False , ) Warning these (captcha) settings can not be changed at runtime! \u00b6 since the schema can not be changed at runtime. \u00b6","title":"Installation"},{"location":"installation/#installation","text":"Attention If you are not familiarized with Strawberry or Strawberry Django JWT , skip this installation section and go to the quickstart guide.","title":"Installation"},{"location":"installation/#requirements","text":"Python: 3.10 Django: 4.0","title":"Requirements"},{"location":"installation/#installation_1","text":"pip install strawberry-django-auth For those that are not installed, this will automatically install strawberry , strawberry-django , strawberry-django-jwt , django . Add gqlauth to installed apps. INSTALLED_APPS = [ # ... \"gqlauth\" ] Migrate: python manage.py migrate","title":"Installation"},{"location":"installation/#setup","text":"The following are the minimum steps required to get it running. It should not take more than 10 minutes.","title":"Setup"},{"location":"installation/#1-schema","text":"","title":"1. Schema"},{"location":"installation/#in-your-schema-add-the-following","text":"Schema # yourapp/users/schema.py import strawberry from gqlauth.user.queries import UserQueries GraphQl Relay from gqlauth.user import arg_mutations @strawberry . type class UserMutations : token_auth = arg_mutations . ObtainJSONWebToken . field # login mutation verify_token = arg_mutations . VerifyToken . field refresh_token = arg_mutations . RefreshToken . field revoke_token = arg_mutations . RevokeToken . field register = arg_mutations . Register . field verify_account = arg_mutations . VerifyAccount . field update_account = arg_mutations . UpdateAccount . field resend_activation_email = arg_mutations . ResendActivationEmail . field archive_account = arg_mutations . ArchiveAccount . field delete_account = arg_mutations . DeleteAccount . field password_change = arg_mutations . PasswordChange . field send_password_reset_email = arg_mutations . SendPasswordResetEmail . field password_reset = arg_mutations . PasswordReset . field password_set = arg_mutations . PasswordSet . field verify_secondary_email = arg_mutations . VerifySecondaryEmail . field swap_emails = arg_mutations . SwapEmails . field remove_secondary_email = arg_mutations . RemoveSecondaryEmail . field send_secondary_email_activation = arg_mutations . SendSecondaryEmailActivation . field from gqlauth.user import relay @strawberry . type class UserMutations : token_auth = relay . ObtainJSONWebToken . field # login mutation verify_token = relay . VerifyToken . field refresh_token = relay . RefreshToken . field revoke_token = relay . RevokeToken . field register = relay . Register . field verify_account = relay . VerifyAccount . field update_account = relay . UpdateAccount . field resend_activation_email = relay . ResendActivationEmail . field archive_account = relay . ArchiveAccount . field delete_account = relay . DeleteAccount . field password_change = relay . PasswordChange . field send_password_reset_email = relay . SendPasswordResetEmail . field password_reset = relay . PasswordReset . field password_set = relay . PasswordSet . field verify_secondary_email = relay . VerifySecondaryEmail . field swap_emails = relay . SwapEmails . field remove_secondary_email = relay . RemoveSecondaryEmail . field send_secondary_email_activation = relay . SendSecondaryEmailActivation . field # yourapp/schema.py import strawberry from strawberry.tools import merge_types from users.schema import UserMutations , UserQueries Query = merge_types ( \"RootQuery\" , ( UserQueries ,)) Mutation = merge_types ( \"RootMutation\" , ( UserMutations ,)) schema = strawberry . Schema ( query = Query , mutation = Mutation )","title":"In your schema add the following:"},{"location":"installation/#2-allow-any-classes","text":"Please refer to strawberry-django-jwt . as it is not trivially possible with strawberry.","title":"2. Allow Any Classes"},{"location":"installation/#3-authentication-backend-optional","text":"Add the following to your AUTHENTICATION_BACKENDS : AUTHENTICATION_BACKENDS = [ # remove this # \"strawberry_django_jwt.backends.JSONWebTokenBackend\", # add this \"gqlauth.backends.GraphQLAuthBackend\" , # ... ] What's the difference from the strawberry_django_jwt.backend? We implement the same backend with only one difference: It will not raise if you send a request with bad token to a class that is not on JWT_ALLOW_ANY_CLASSES . Why should I want this behaivor? Instead of raising an actual error, we can handle it and return whatever make sense, e.g.: cls ( success = False errors = \"Unauthenticated.\" ) You should handle this situation doing one of the following: Simply use the strawberry_django_jwt decorator @login_required . Use our login_required decorator , note that this expect your output to contain this output . Create your own login_required decorator!","title":"3. Authentication Backend - optional"},{"location":"installation/#4-refresh-token-optional","text":"Explanation Refresh tokens are concept of jwt-web-tokens what they mean is that every x time a so called logged user will need to request for a new token from the server and generally there are two types of them: Single token refresh (and that's the default) Long running refresh tokens Single token refresh Long running refresh tokens they will require the user to ask for refresh token every 5 minutes Warning most importantly won't use the database therefore it is not state-less for more information head to Django GraphQL JWT they will require the database (threfore migration) are state-less you should probably follow Django GraphQL JWT docs for more information docs :wink: but here is a TL;DR: to set this up: INSTALLED_APPS = [ # ... \"strawberry_django_jwt.refresh_token\" , ] GRAPHQL_JWT = { # ... \"JWT_VERIFY_EXPIRATION\" : True , \"JWT_LONG_RUNNING_REFRESH_TOKEN\" : True , \"JWT_EXPIRATION_DELTA\" : timedelta ( minutes = 5 ), \"JWT_REFRESH_EXPIRATION_DELTA\" : timedelta ( days = 7 ), } And remember to migrate: python -m manage migrate","title":"4. Refresh Token - optional"},{"location":"installation/#5-email-templates","text":"Overriding email templates is covered here . This package comes with some default email templates, if you plan to use it, make sure your templates configuration has the following: TEMPLATES = [ { # ... 'APP_DIRS' : True , }, ]","title":"5. Email Templates"},{"location":"installation/#6-email-backend","text":"The default configuration is to send activation email, you can set it to False on your settings , but you still need an Email Backend to password reset. The quickest way for development is to setup a Console Email Backend , simply add the following to your settings.py . EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend' Now all emails are sent to the standard output, instead of an actual email.","title":"6. Email Backend"},{"location":"installation/#7-overriding-settings","text":"let's disable captcha validation. in your settings.py add the following: # settings.py from gqlauth.settings_type import GqlAuthSettings GQL_AUTH = GqlAuthSettings ( LOGIN_REQUIRE_CAPTHA = False , REGISTER_REQUIRE_CAPTCHA = False , ) Warning","title":"7. Overriding settings"},{"location":"installation/#these-captcha-settings-can-not-be-changed-at-runtime","text":"","title":"these (captcha) settings can not be changed at runtime!"},{"location":"installation/#since-the-schema-can-not-be-changed-at-runtime","text":"","title":"since the schema can not be changed at runtime."},{"location":"overriding-email-templates/","text":"Overriding Email Templates \u00b6 The default email templates are just examples, you probably want to customize it. Update your settings: \u00b6 # settings.py import os TEMPLATES = [ { #... \"DIRS\" : [ os . path . join ( BASE_DIR , \"templates\" )], # ... }, ] File and folder sctructure \u00b6 Create the following folder and files structure: - project_name/ - project_name/ - templates/ email/ activation_email.html activation_subject.txt password_reset_email.html password_reset_subject.txt db.sqlite3 manage.py This is the minimum. Check the email templates settings , you can create custom templates for: account activation resend account activation email password reset email secondary email activation Email variables \u00b6 Both subject and email templates receive the following variables: user token \u2192 account activation / password reset / secondary-email activation port site_name \u2192 from django sites framework (optional) domain \u2192 from django sites framework (optional) protocol path \u2192 defined in settings (some frontend path) request timestamp custom variables defined using EMAIL_TEMPLATE_VARIABLES setting \u2192 defined in settings Writing the templates \u00b6 Write your templates like this: <!-- activation_email.html --> < h3 > {{ site_name }} </ h3 > < p > Hello \\{{ user.username }}! </ p > < p > Please activate your account on the link: </ p > < p > {{ protocol }}://{{ domain }}/{{ path }}/{{ token }} </ p > Provide only the html template. It will be converted to text later.","title":"Overriding email templates"},{"location":"overriding-email-templates/#overriding-email-templates","text":"The default email templates are just examples, you probably want to customize it.","title":"Overriding Email Templates"},{"location":"overriding-email-templates/#update-your-settings","text":"# settings.py import os TEMPLATES = [ { #... \"DIRS\" : [ os . path . join ( BASE_DIR , \"templates\" )], # ... }, ]","title":"Update your settings:"},{"location":"overriding-email-templates/#file-and-folder-sctructure","text":"Create the following folder and files structure: - project_name/ - project_name/ - templates/ email/ activation_email.html activation_subject.txt password_reset_email.html password_reset_subject.txt db.sqlite3 manage.py This is the minimum. Check the email templates settings , you can create custom templates for: account activation resend account activation email password reset email secondary email activation","title":"File and folder sctructure"},{"location":"overriding-email-templates/#email-variables","text":"Both subject and email templates receive the following variables: user token \u2192 account activation / password reset / secondary-email activation port site_name \u2192 from django sites framework (optional) domain \u2192 from django sites framework (optional) protocol path \u2192 defined in settings (some frontend path) request timestamp custom variables defined using EMAIL_TEMPLATE_VARIABLES setting \u2192 defined in settings","title":"Email variables"},{"location":"overriding-email-templates/#writing-the-templates","text":"Write your templates like this: <!-- activation_email.html --> < h3 > {{ site_name }} </ h3 > < p > Hello \\{{ user.username }}! </ p > < p > Please activate your account on the link: </ p > < p > {{ protocol }}://{{ domain }}/{{ path }}/{{ token }} </ p > Provide only the html template. It will be converted to text later.","title":"Writing the templates"},{"location":"quickstart/","text":"Quickstart \u00b6 What to expect \u00b6 Fully functional API to handle user account Both graphQL and Relay versions Setup with custom user model 20 to 30 minutes Final code on github . Start a new Django Project \u00b6 It's recommended to use virtual env wrapper or virtualenv to create your project inside an isolated python environment. We will use the first. Create the virtual env \u00b6 python -m venv venv cd venv/bin source activate.sh Create the Django Project \u00b6 First install django: python -m pip install django Then, create the new project: django-admin startproject quickstart cd quickstart Create the custom user model \u00b6 Changing to a custom user model mid-project is significantly more difficult. So let's start by adding it now. Run the following: python manage.py startapp users Then, create the custom user model: # users/models.py from django.contrib.auth.models import AbstractUser class CustomUser ( AbstractUser ): email = models . EmailField ( blank = False , max_length = 254 , verbose_name = \"email address\" ) USERNAME_FIELD = \"username\" # e.g: \"username\", \"email\" EMAIL_FIELD = \"email\" # e.g: \"email\", \"primary_email\" Add it to the settings: # quickstart/settings.py INSTALLED_APPS = [ # ... 'users' ] AUTH_USER_MODEL = 'users.CustomUser' Finally, migrate: python manage.py migrate You can customize the mutations to match your custom user model fields, see the dynamic-fields settings . Setup strawberry and strawberry-jwt \u00b6 What is strawberry-django? strawberry-django is small wrapper around strawberry that makes it easy to integrate strawberry with django. although we utilize it only for user queries, mutations are pure strawberry. What is strawberry-django-jwt? strawberry-django-jwt is a forked version of Django-Graphql-Jwt and is the easiest way to add JSON Web token authentication for Django with strawberry. strawberry-django quick start - copied Installation \u00b6 python -m pip install strawberry_graphql_django Add the url \u00b6 # quickstart.urls.py from django.urls import path from django.views.decorators.csrf import csrf_exempt from strawberry.django.views import GraphQLView urlpatterns = [ # ... path ( \"graphql\" , csrf_exempt ( GraphQLView . as_view ( graphiql = True ))), ] Sample project \u00b6 Let's start from Django model called Fruit, which has two attributes, name and color. # models.py from django.db import models class Fruit ( models . Model ): name = models . CharField ( max_length = 20 ) color = models . CharField ( max_length = 20 ) Soon after that your Boss comes and asks you to implement API for that model so that everyone can access our great fruit database from all over the world. Fruit model has name and color attributes and we want to publish them both. GraphQL output type for our model is generated by using strawberry_django.type decorator. Both fields are char fields which means that we want to use python str type for them. # types.py import strawberry_django from . import models @strawberry_django . type ( models . Fruit ) class Fruit : name : str color : str Last step is to generate Query type and Schema. Core package strawberry helps us here. # schema.py import strawberry from typing import List from .types import Fruit @strawberry . type class Query : fruits : List [ Fruit ] = strawberry . django . field () schema = strawberry . Schema ( query = Query ) Finally we add AsyncGraphQLView view into our urls so that we can start making first queries. # urls.py from django.urls import include , path from strawberry.django.views import AsyncGraphQLView from .schema import schema urlpatterns = [ path ( 'graphql' , AsyncGraphQLView . as_view ( schema = schema )), ] After that, once the development server is running, you can read your fruits from the database. query { fruits { name color } } # -> fruits: [{ name: \"strawberry\", color: \"red\" }] Model Relations \u00b6 Let's create another model called Color and add foreign key relation between Fruit and Color models. # models.py from django.db import models class Fruit ( models . Model ): name = models . CharField ( max_length = 20 ) color = models . ForeignKey ( 'Color' , related_name = 'fruits' , on_delete = models . CASCADE ) class Color ( models . Model ): name = models . CharField ( max_length = 20 ) We also need to add another type and modify existing one. Field type auto is used for type auto resolution. strawberry_django goes through all fields and resolves field types. It also generates resolvers for relation fields on behalf you. # types.py import strawberry_django from strawberry import auto from typing import List from . import models @strawberry_django . type ( models . Fruit ) class Fruit : id : auto name : auto color : 'Color' @strawberry_django . type ( models . Color ) class Color : id : auto name : auto fruits : List [ Fruit ] This generates schema like this type Color { id: ID! name: String! fruits: [Fruit!] } type Fruit { id: ID! name: String! color: Color! } type Query { fruits: [Fruit!]! } Now you can start making queries and request all fruits and their colors from the database. query { fruits { name color { name } } } # fruits: [ # { name: \"strawberry\", color: { name: \"red\" } }, # { name: \"raspberry\", color: { name: \"red\" } } # ] strawberry-django-jwt setup - copied ## Installation Install last stable version from Pypi: pip install strawberry-django-jwt Add AuthenticationMiddleware middleware to your MIDDLEWARE settings: MIDDLEWARE = [ ... , 'django.contrib.auth.middleware.AuthenticationMiddleware' , ... , ] Add following django apps to INSTALLED_APPS : INSTALLED_APPS = [ 'django.contrib.auth' , 'django.contrib.contenttypes' , 'django.contrib.sessions' , ... , ] If using refresh tokens, also add strawberry_django_jwt.refresh_token INSTALLED_APPS = [ 'django.contrib.auth' , 'django.contrib.contenttypes' , 'django.contrib.sessions' , ... , 'strawberry_django_jwt.refresh_token' , ... , ] Add JSONWebTokenMiddleware or AsyncJSONWebTokenMiddleware middleware to your STRAWBERRY schema definition: from strawberry_django_jwt.middleware import JSONWebTokenMiddleware , AsyncJSONWebTokenMiddleware from strawberry import Schema # !! IMPORTANT !! # Pick only one, async middleware is needed when using AsyncGraphQLSchema schema = Schema ( ... , extensions = [ JSONWebTokenMiddleware , AsyncJSONWebTokenMiddleware , ]) Add JSONWebTokenBackend backend to your AUTHENTICATION_BACKENDS : AUTHENTICATION_BACKENDS = [ 'strawberry_django_jwt.backends.JSONWebTokenBackend' , 'django.contrib.auth.backends.ModelBackend' , ] Add strawberry-django-jwt mutations to the root schema: import strawberry import strawberry_django_jwt.mutations as jwt_mutations @strawberry . type class Mutation : token_auth = jwt_mutations . ObtainJSONWebToken . obtain verify_token = jwt_mutations . Verify . verify refresh_token = jwt_mutations . Refresh . refresh delete_token_cookie = jwt_mutations . DeleteJSONWebTokenCookie . delete_cookie schema = strawberry.Schema(mutation=Mutation, query=...) [OPTIONAL] Set up the custom Strawberry views These views set the status code of failed authentication attempts to 401 instead of the default 200. from django.urls import re_path from strawberry_django_jwt.decorators import jwt_cookie from strawberry_django_jwt.views import StatusHandlingGraphQLView as GQLView from ... import schema urlpatterns += \\ [ re_path ( r '^graphql/?$' , jwt_cookie ( GQLView . as_view ( schema = schema ))), ] or, for async views: from django.urls import re_path from strawberry_django_jwt.decorators import jwt_cookie from strawberry_django_jwt.views import AsyncStatusHandlingGraphQLView as AGQLView from ... import schema urlpatterns += \\ [ re_path ( r '^graphql/?$' , jwt_cookie ( AGQLView . as_view ( schema = schema ))), ] Known Issues \u00b6 JWT_ALLOW_ANY_CLASSES Only supports return-type based filtering at the moment, because strawberry does not use class-based field definitions (so all superclasses are dropped) It might be possible to create a workaround by using either a class decorator or by creating a custom graphql scheme that somehow preserves class hierarchy of types After you are done with strawberry-django initialization your settings should look like this: \u00b6 # quickstart.settings.py INSTALLED_APPS = [ # ... 'django.contrib.staticfiles' , # Required for GraphiQL \"strawberry_django\" , # refresh tokens are optional \"strawberry_django_jwt.refresh_token\" , ] MIDDLEWARE = [ # ... 'django.contrib.auth.middleware.AuthenticationMiddleware' , # ... ] AUTHENTICATION_BACKENDS = [ 'strawberry_django_jwt.backends.JSONWebTokenBackend' , 'django.contrib.auth.backends.ModelBackend' , ] GRAPHQL_JWT = { \"JWT_VERIFY_EXPIRATION\" : True , # optional \"JWT_LONG_RUNNING_REFRESH_TOKEN\" : True , } If you choose to use the refresh tokens, remember to migrate: python -m manage migrate Install strawberry-django-auth \u00b6 pip install strawberry-django-auth # settings.py INSTALLED_APPS = [ # ... \"gqlauth\" , ] AUTHENTICATION_BACKENDS = [ # remove this # \"strawberry_django_jwt.backends.JSONWebTokenBackend\", # add this \"gqlauth.backends.GraphQLAuthBackend\" , # ... ] Here is an explanation why we are adding this backend. And make sure your templates configuration has the following: TEMPLATES = [ { # ... 'APP_DIRS' : True , }, ] Run: python -m manage migrate Now let's disable captcha validation for setup ease. in your settings.py add the following: # settings.py from gqlauth.settings_type import GqlAuthSettings GQL_AUTH = GqlAuthSettings ( LOGIN_REQUIRE_CAPTCHA = False , REGISTER_REQUIRE_CAPTCHA = False , ) Warning these (captcha) settings can not be changed at runtime! \u00b6 since the schema can not be changed at runtime. \u00b6 Query \u00b6 Create the schema \u00b6 Create a file called schema.py next to your settings.py with the following: # quickstart.schema.py import strawberry from gqlauth.user.queries import UserQueries from strawberry_django_jwt.middleware import JSONWebTokenMiddleware schema = strawberry . Schema ( query = UserQueries , extensions = [ JSONWebTokenMiddleware , ], ) you can choose what fields to include like this import strawberry from gqlauth.user.queries import UserQueries , UserType from django.contrib.auth import get_user_model @strawberry . django . type ( model = get_user_model ()) class MyQueries : me : UserType = UserQueries . me public : UserType = UserQueries . public_user # etc... Load fixtures \u00b6 Before starting to query, let's load some users on the database. Create a new file called users.json in the same directory as manage.py with the following: Have a look on the fixtures, note that we are creating 4 users and 3 UserStatus . When creating a user, we create a relating UserStatus by default on post_save signal with the following fields: verified = False archived = False secondary_email = None You can access it on any user: user.status. [ verified | archived | secondary_email ] [ { \"model\" : \"users.CustomUser\" , \"pk\" : 1 , \"fields\" : { \"password\" : \"pbkdf2_sha256$180000$nFcBtiqGnWN9$hf58wNg77oT1BlNKRdATVVvBIa69+dz22fL1JKOKTaA=\" , \"last_login\" : null , \"is_superuser\" : false , \"username\" : \"user1\" , \"first_name\" : \"\" , \"last_name\" : \"\" , \"email\" : \"user1@email.com\" , \"is_staff\" : false , \"is_active\" : true } }, { \"model\" : \"users.CustomUser\" , \"pk\" : 2 , \"fields\" : { \"password\" : \"pbkdf2_sha256$180000$nFcBtiqGnWN9$hf58wNg77oT1BlNKRdATVVvBIa69+dz22fL1JKOKTaA=\" , \"last_login\" : null , \"is_superuser\" : false , \"username\" : \"user2\" , \"first_name\" : \"\" , \"last_name\" : \"\" , \"email\" : \"user2@email.com\" , \"is_staff\" : false , \"is_active\" : true } }, { \"model\" : \"gqlauth.userstatus\" , \"pk\" : 2 , \"fields\" : { \"user\" : 2 , \"verified\" : true , \"archived\" : false , \"secondary_email\" : null } }, { \"model\" : \"users.CustomUser\" , \"pk\" : 3 , \"fields\" : { \"password\" : \"pbkdf2_sha256$180000$nFcBtiqGnWN9$hf58wNg77oT1BlNKRdATVVvBIa69+dz22fL1JKOKTaA=\" , \"last_login\" : null , \"is_superuser\" : false , \"username\" : \"user3\" , \"first_name\" : \"\" , \"last_name\" : \"\" , \"email\" : \"user3@email.com\" , \"is_staff\" : false , \"is_active\" : true } }, { \"model\" : \"gqlauth.userstatus\" , \"pk\" : 3 , \"fields\" : { \"user\" : 3 , \"verified\" : true , \"archived\" : true , \"secondary_email\" : null } }, { \"model\" : \"users.CustomUser\" , \"pk\" : 4 , \"fields\" : { \"password\" : \"pbkdf2_sha256$180000$nFcBtiqGnWN9$hf58wNg77oT1BlNKRdATVVvBIa69+dz22fL1JKOKTaA=\" , \"last_login\" : null , \"is_superuser\" : false , \"username\" : \"user4\" , \"first_name\" : \"\" , \"last_name\" : \"\" , \"email\" : \"user4@email.com\" , \"is_staff\" : false , \"is_active\" : true } }, { \"model\" : \"gqlauth.userstatus\" , \"pk\" : 4 , \"fields\" : { \"user\" : 4 , \"verified\" : true , \"archived\" : false , \"secondary_email\" : \"user4_secondary@email.com\" } } ] run: python -m manage loaddata users.json Making your first query \u00b6 Start the dev server: python manage.py runserver Open your browser: http://127.0.0.1:8000/graphql This will open the GraphiQL API browser , where you can play with your queries and mutations, also let you explore the schema. Copy the query below, paste on the GraphiQL interface and hit the play button. Gql query response query { users{ username, archived, verified, email, secondaryEmail, } } { \"data\" : { \"users\" : [ { \"username\" : \"user1\" , \"archived\" : false , \"verified\" : false , \"email\" : \"user1@email.com\" , \"secondaryEmail\" : null }, { \"username\" : \"user2\" , \"archived\" : false , \"verified\" : true , \"email\" : \"user2@email.com\" , \"secondaryEmail\" : null }, { \"username\" : \"user3\" , \"archived\" : true , \"verified\" : true , \"email\" : \"user3@email.com\" , \"secondaryEmail\" : null }, { \"username\" : \"user4\" , \"archived\" : false , \"verified\" : true , \"email\" : \"user4@email.com\" , \"secondaryEmail\" : \"user4_secondary@email.com\" } ] } } Query with filters \u00b6 The UserQuery comes with some default filters: Gql query response { users(filters: {status: {archived: true}}) { username archived verified email secondaryEmail } } { \"data\": { \"users\": [ { \"username\": \"user3\", \"archived\": true, \"verified\": true, \"email\": \"user3@email.com\", \"secondaryEmail\": null } ] } } Take a minute to explore the GraphiQL API browser and query schema on the right upper corner under docs tab. MeQuery \u00b6 With MeQuery you can retrieve data for the currently authenticated user: Gql query response query { me { username, verified } } { \"data\": { \"user\": { \"username\": \"new_user\", \"verified\": true } } } Since this query requires an authenticated user it can only be explored by using the insomnia API client . See the below for more on how to use Insomnia. Setup Email Backend \u00b6 The default configuration is to send activation email when registering users, you can set it to False on your settings , but you still need an Email Backend to password reset. The quickest solution for development is to setup a Console Email Backend , simply add the following to your settings.py . EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend' Now all emails are sent to the standard output, instead of an actual email and we are ready to continue this guide. Mutations \u00b6 Now let's add some mutations to our schema, starting with the registration. On the schema.py add the following: Register arg_mutations relay # quickstart.schema.py import strawberry from gqlauth.schema import UserQueries from gqlauth.user import arg_mutations from strawberry_django_jwt.middleware import JSONWebTokenMiddleware @strawberry . type class UserMutations : register = arg_mutations . Register . field verify_account = arg_mutations . VerifyAccount . field resend_activation_email = arg_mutations . ResendActivationEmail . field send_password_reset_email = arg_mutations . SendPasswordResetEmail . field password_reset = arg_mutations . PasswordReset . field password_set = arg_mutations . PasswordSet . field password_change = arg_mutations . PasswordChange . field archive_account = arg_mutations . ArchiveAccount . field delete_account = arg_mutations . DeleteAccount . field update_account = arg_mutations . UpdateAccount . field send_secondary_email_activation = arg_mutations . SendSecondaryEmailActivation . field verify_secondary_email = arg_mutations . VerifySecondaryEmail . field swap_emails = arg_mutations . SwapEmails . field captcha = arg_mutations . Cap . field # django-graphql-jwt authentication # with some extra features token_auth = arg_mutations . ObtainJSONWebToken . field verify_token = arg_mutations . VerifyToken . field refresh_token = arg_mutations . RefreshToken . field revoke_token = arg_mutations . RevokeToken . field schema = strawberry . Schema ( query = UserQueries , mutation = UserMutations , extensions = [ JSONWebTokenMiddleware , ], ) # quickstart.schema.py import strawberry from gqlauth.schema import UserQueries from gqlauth.user import relay from strawberry_django_jwt.middleware import JSONWebTokenMiddleware @strawberry . type class UserMutations : register = relay . Register . field verify_account = relay . VerifyAccount . field resend_activation_email = relay . ResendActivationEmail . field send_password_reset_email = relay . SendPasswordResetEmail . field password_reset = relay . PasswordReset . field password_set = relay . PasswordSet . field password_change = relay . PasswordChange . field archive_account = relay . ArchiveAccount . field delete_account = relay . DeleteAccount . field update_account = relay . UpdateAccount . field send_secondary_email_activation = relay . SendSecondaryEmailActivation . field verify_secondary_email = relay . VerifySecondaryEmail . field swap_emails = relay . SwapEmails . field captcha = relay . Cap . field # django-graphql-jwt authentication # with some extra features token_auth = relay . ObtainJSONWebToken . field verify_token = relay . VerifyToken . field refresh_token = relay . RefreshToken . field revoke_token = relay . RevokeToken . field schema = strawberry . Schema ( query = UserQueries , mutation = UserMutations , extensions = [ JSONWebTokenMiddleware , ], ) Take a minute to explore the schema on the documentation tab again. Let's try to register a new user: \u00b6 Failure gql relay response mutation { register( email: \"new_user@email.com\", username: \"new_user\", password1: \"123456\", password2: \"123456\", ) { success, errors, } } mutation { register( input: { email: \"new_user@email.com\", username: \"new_user\", password1: \"123456\", password2: \"123456\", } ) { success, errors, token, refreshToken } } { \"data\" : { \"register\" : { \"success\" : false , \"errors\" : { \"password2\" : [ { \"message\" : \"This password is too short. It must contain at least 8 characters.\" , \"code\" : \"password_too_short\" }, { \"message\" : \"This password is too common.\" , \"code\" : \"password_too_common\" }, { \"message\" : \"This password is entirely numeric.\" , \"code\" : \"password_entirely_numeric\" } ] } } } } Something went wrong! Now you know the response format that you can expect of all mutations. Let's try again: Success arg_mutation relay response mutation { register( email: \"new_user@email.com\", username: \"new_user\", password1: \"SuperSecureP@sw0rd\", password2: \"SuperSecureP@sw0rd\", ) { success, errors, success } } mutation { register( input: { email: \"new_user@email.com\", username: \"new_user\", password1: \"SuperSecureP@sw0rd\", password2: \"SuperSecureP@sw0rd\", } ) { success, errors, token, refreshToken } } { \"data\" : { \"register\" : { \"success\" : true , \"errors\" : null } } } Now Check if the new user is really on the database: Check query response query{ users(filters: {username: \"new_user\"}) { id username email isActive archived, verified, secondaryEmail } } { \"data\" : { \"users\" : [ { \"id\" : \"5\" , \"username\" : \"new_user\" , \"email\" : \"new_user@email.com\" , \"isActive\" : true , \"archived\" : false , \"verified\" : false , \"secondaryEmail\" : null } ] } } There is actually a new user and it is possible to log in (you can change it on the settings ), but it is not verified yet. Save the id of the new user, so we can query it later. Go to your console and note the email that has been sent. Should be two outputs, html and plain text formats. Save the token from the url, something like this: eyJ1c2VybmFtZSI6Im5ld191c2VyIiwiYWN0aW9uIjoiYWN0aXZhdGlvbiJ9:1isoSr:CDwK_fjBSxWj3adC-X16wqzv-Mw Account Verification \u00b6 search your schema for verify_account : should look like this: Now let's try to verify the account: \u00b6 Gql arg_mutation relay result mutation { verifyAccount(token: \"YOUR TOKEN HERE\") { success, errors } } mutation { verifyAccount ( input : { token : \"<YOUR TOKEN HERE>\" } ) { success , errors } } { \"data\" : { \"verifyAccount\" : { \"success\" : true , \"errors\" : null } } } Check if the user is verified using the id that you have saved early: Gql query response query { user (pk: \"<USER ID>\"){ username, verified } } { \"data\" : { \"user\" : { \"username\" : \"new_user\" , \"verified\" : true } } } Login \u00b6 search your schema for tokenAuth : should look like this: Let's try to login: \u00b6 Gql arg_mutation relay response mutation { tokenAuth(username: \"new_user\", password: \"SuperSecureP@sw0rd\") { success errors obtainPayload { token refreshToken refreshExpiresIn payload { exp origIat username } } } } mutation login { tokenAuth(input: {username: \"new_user\", password: \"SuperSecureP@sw0rd\"}) { success errors obtainPayload { token refreshToken refreshExpiresIn payload { exp origIat username } } } } { \"data\" : { \"tokenAuth\" : { \"success\" : true , \"errors\" : null , \"obtainPayload\" : { \"token\" : \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE2NTM2MDkxOTQsIm9yaWdJYXQiOjE2NTM2MDg4OTQsInVzZXJuYW1lIjoibmV3X3VzZXIxIn0.FxXaWKToi5mTzPcKAz16K2GWnIvsTBKio_BEyCdF5fs\" , \"refreshToken\" : \"e7a784476810f880eb93f3827cd881d834235598\" , \"refreshExpiresIn\" : 1654213694 , \"payload\" : { \"exp\" : 1653609194 , \"origIat\" : 1653608894 , \"username\" : \"new_user1\" } } } } } Save this token , we are going to use it to do some protected actions. The GraphiQL interface that comes with Graphene is great! But to try all features, we need to send this token on the header and the GraphiQL do not support this. Insomnia API client \u00b6 We are going to use insomnia API client to send request with authorization header. It is really easy to setup, simple follow the instructions on the site. Install and come back here! Update Account \u00b6 search in your schema for updateAccount it should look like this: This is the first mutation with login required that we are going to test. On the insomnia, create a new request and call it updateAccount . Select the method POST . On the top of the window, add your graphql url: http://127.0.0.1:8000/graphql For the body, select GraphQL Query . Now it works exactly as the graphiQL. On the headers pane, create a new header: name: Authorization value: JWT <TOKEN FROM THE LOGIN> Make the query: Gql arg_mutation relay response mutation { updateAccount( firstName: \"Joe\" ) { success, errors } } mutation { updateAccount( input: { firstName: \"Joe\" } ) { success, errors } } { \"data\" : { \"updateAccount\" : { \"success\" : true , \"errors\" : null } } } If it fails because of the token (in case you took some time and it has expired), make the login again and get a new token. Check if it worked: Gql query response query { user (id: \"<USER ID>\"){ username, firstName } } { \"data\" : { \"user\" : { \"username\" : \"new_user\" , \"firstName\" : \"Joe\" } } } Next steps \u00b6 explore all the mutations. Navigate through the GraphiQL Documentation Explorer. Change the settings . Explore the api . check our decorators . make sure you are familiar with our captcha system. Override email templates . Explore these useful links .","title":"Quickstart"},{"location":"quickstart/#quickstart","text":"","title":"Quickstart"},{"location":"quickstart/#what-to-expect","text":"Fully functional API to handle user account Both graphQL and Relay versions Setup with custom user model 20 to 30 minutes Final code on github .","title":"What to expect"},{"location":"quickstart/#start-a-new-django-project","text":"It's recommended to use virtual env wrapper or virtualenv to create your project inside an isolated python environment. We will use the first.","title":"Start a new Django Project"},{"location":"quickstart/#create-the-virtual-env","text":"python -m venv venv cd venv/bin source activate.sh","title":"Create the virtual env"},{"location":"quickstart/#create-the-django-project","text":"First install django: python -m pip install django Then, create the new project: django-admin startproject quickstart cd quickstart","title":"Create the Django Project"},{"location":"quickstart/#create-the-custom-user-model","text":"Changing to a custom user model mid-project is significantly more difficult. So let's start by adding it now. Run the following: python manage.py startapp users Then, create the custom user model: # users/models.py from django.contrib.auth.models import AbstractUser class CustomUser ( AbstractUser ): email = models . EmailField ( blank = False , max_length = 254 , verbose_name = \"email address\" ) USERNAME_FIELD = \"username\" # e.g: \"username\", \"email\" EMAIL_FIELD = \"email\" # e.g: \"email\", \"primary_email\" Add it to the settings: # quickstart/settings.py INSTALLED_APPS = [ # ... 'users' ] AUTH_USER_MODEL = 'users.CustomUser' Finally, migrate: python manage.py migrate You can customize the mutations to match your custom user model fields, see the dynamic-fields settings .","title":"Create the custom user model"},{"location":"quickstart/#setup-strawberry-and-strawberry-jwt","text":"What is strawberry-django? strawberry-django is small wrapper around strawberry that makes it easy to integrate strawberry with django. although we utilize it only for user queries, mutations are pure strawberry. What is strawberry-django-jwt? strawberry-django-jwt is a forked version of Django-Graphql-Jwt and is the easiest way to add JSON Web token authentication for Django with strawberry. strawberry-django quick start - copied","title":"Setup strawberry and strawberry-jwt"},{"location":"quickstart/#installation","text":"python -m pip install strawberry_graphql_django","title":"Installation"},{"location":"quickstart/#add-the-url","text":"# quickstart.urls.py from django.urls import path from django.views.decorators.csrf import csrf_exempt from strawberry.django.views import GraphQLView urlpatterns = [ # ... path ( \"graphql\" , csrf_exempt ( GraphQLView . as_view ( graphiql = True ))), ]","title":"Add the url"},{"location":"quickstart/#sample-project","text":"Let's start from Django model called Fruit, which has two attributes, name and color. # models.py from django.db import models class Fruit ( models . Model ): name = models . CharField ( max_length = 20 ) color = models . CharField ( max_length = 20 ) Soon after that your Boss comes and asks you to implement API for that model so that everyone can access our great fruit database from all over the world. Fruit model has name and color attributes and we want to publish them both. GraphQL output type for our model is generated by using strawberry_django.type decorator. Both fields are char fields which means that we want to use python str type for them. # types.py import strawberry_django from . import models @strawberry_django . type ( models . Fruit ) class Fruit : name : str color : str Last step is to generate Query type and Schema. Core package strawberry helps us here. # schema.py import strawberry from typing import List from .types import Fruit @strawberry . type class Query : fruits : List [ Fruit ] = strawberry . django . field () schema = strawberry . Schema ( query = Query ) Finally we add AsyncGraphQLView view into our urls so that we can start making first queries. # urls.py from django.urls import include , path from strawberry.django.views import AsyncGraphQLView from .schema import schema urlpatterns = [ path ( 'graphql' , AsyncGraphQLView . as_view ( schema = schema )), ] After that, once the development server is running, you can read your fruits from the database. query { fruits { name color } } # -> fruits: [{ name: \"strawberry\", color: \"red\" }]","title":"Sample project"},{"location":"quickstart/#model-relations","text":"Let's create another model called Color and add foreign key relation between Fruit and Color models. # models.py from django.db import models class Fruit ( models . Model ): name = models . CharField ( max_length = 20 ) color = models . ForeignKey ( 'Color' , related_name = 'fruits' , on_delete = models . CASCADE ) class Color ( models . Model ): name = models . CharField ( max_length = 20 ) We also need to add another type and modify existing one. Field type auto is used for type auto resolution. strawberry_django goes through all fields and resolves field types. It also generates resolvers for relation fields on behalf you. # types.py import strawberry_django from strawberry import auto from typing import List from . import models @strawberry_django . type ( models . Fruit ) class Fruit : id : auto name : auto color : 'Color' @strawberry_django . type ( models . Color ) class Color : id : auto name : auto fruits : List [ Fruit ] This generates schema like this type Color { id: ID! name: String! fruits: [Fruit!] } type Fruit { id: ID! name: String! color: Color! } type Query { fruits: [Fruit!]! } Now you can start making queries and request all fruits and their colors from the database. query { fruits { name color { name } } } # fruits: [ # { name: \"strawberry\", color: { name: \"red\" } }, # { name: \"raspberry\", color: { name: \"red\" } } # ] strawberry-django-jwt setup - copied ## Installation Install last stable version from Pypi: pip install strawberry-django-jwt Add AuthenticationMiddleware middleware to your MIDDLEWARE settings: MIDDLEWARE = [ ... , 'django.contrib.auth.middleware.AuthenticationMiddleware' , ... , ] Add following django apps to INSTALLED_APPS : INSTALLED_APPS = [ 'django.contrib.auth' , 'django.contrib.contenttypes' , 'django.contrib.sessions' , ... , ] If using refresh tokens, also add strawberry_django_jwt.refresh_token INSTALLED_APPS = [ 'django.contrib.auth' , 'django.contrib.contenttypes' , 'django.contrib.sessions' , ... , 'strawberry_django_jwt.refresh_token' , ... , ] Add JSONWebTokenMiddleware or AsyncJSONWebTokenMiddleware middleware to your STRAWBERRY schema definition: from strawberry_django_jwt.middleware import JSONWebTokenMiddleware , AsyncJSONWebTokenMiddleware from strawberry import Schema # !! IMPORTANT !! # Pick only one, async middleware is needed when using AsyncGraphQLSchema schema = Schema ( ... , extensions = [ JSONWebTokenMiddleware , AsyncJSONWebTokenMiddleware , ]) Add JSONWebTokenBackend backend to your AUTHENTICATION_BACKENDS : AUTHENTICATION_BACKENDS = [ 'strawberry_django_jwt.backends.JSONWebTokenBackend' , 'django.contrib.auth.backends.ModelBackend' , ] Add strawberry-django-jwt mutations to the root schema: import strawberry import strawberry_django_jwt.mutations as jwt_mutations @strawberry . type class Mutation : token_auth = jwt_mutations . ObtainJSONWebToken . obtain verify_token = jwt_mutations . Verify . verify refresh_token = jwt_mutations . Refresh . refresh delete_token_cookie = jwt_mutations . DeleteJSONWebTokenCookie . delete_cookie schema = strawberry.Schema(mutation=Mutation, query=...) [OPTIONAL] Set up the custom Strawberry views These views set the status code of failed authentication attempts to 401 instead of the default 200. from django.urls import re_path from strawberry_django_jwt.decorators import jwt_cookie from strawberry_django_jwt.views import StatusHandlingGraphQLView as GQLView from ... import schema urlpatterns += \\ [ re_path ( r '^graphql/?$' , jwt_cookie ( GQLView . as_view ( schema = schema ))), ] or, for async views: from django.urls import re_path from strawberry_django_jwt.decorators import jwt_cookie from strawberry_django_jwt.views import AsyncStatusHandlingGraphQLView as AGQLView from ... import schema urlpatterns += \\ [ re_path ( r '^graphql/?$' , jwt_cookie ( AGQLView . as_view ( schema = schema ))), ]","title":"Model Relations"},{"location":"quickstart/#known-issues","text":"JWT_ALLOW_ANY_CLASSES Only supports return-type based filtering at the moment, because strawberry does not use class-based field definitions (so all superclasses are dropped) It might be possible to create a workaround by using either a class decorator or by creating a custom graphql scheme that somehow preserves class hierarchy of types","title":"Known Issues"},{"location":"quickstart/#after-you-are-done-with-strawberry-django-initialization-your-settings-should-look-like-this","text":"# quickstart.settings.py INSTALLED_APPS = [ # ... 'django.contrib.staticfiles' , # Required for GraphiQL \"strawberry_django\" , # refresh tokens are optional \"strawberry_django_jwt.refresh_token\" , ] MIDDLEWARE = [ # ... 'django.contrib.auth.middleware.AuthenticationMiddleware' , # ... ] AUTHENTICATION_BACKENDS = [ 'strawberry_django_jwt.backends.JSONWebTokenBackend' , 'django.contrib.auth.backends.ModelBackend' , ] GRAPHQL_JWT = { \"JWT_VERIFY_EXPIRATION\" : True , # optional \"JWT_LONG_RUNNING_REFRESH_TOKEN\" : True , } If you choose to use the refresh tokens, remember to migrate: python -m manage migrate","title":"After you are done with strawberry-django initialization your settings should look like this:"},{"location":"quickstart/#install-strawberry-django-auth","text":"pip install strawberry-django-auth # settings.py INSTALLED_APPS = [ # ... \"gqlauth\" , ] AUTHENTICATION_BACKENDS = [ # remove this # \"strawberry_django_jwt.backends.JSONWebTokenBackend\", # add this \"gqlauth.backends.GraphQLAuthBackend\" , # ... ] Here is an explanation why we are adding this backend. And make sure your templates configuration has the following: TEMPLATES = [ { # ... 'APP_DIRS' : True , }, ] Run: python -m manage migrate Now let's disable captcha validation for setup ease. in your settings.py add the following: # settings.py from gqlauth.settings_type import GqlAuthSettings GQL_AUTH = GqlAuthSettings ( LOGIN_REQUIRE_CAPTCHA = False , REGISTER_REQUIRE_CAPTCHA = False , ) Warning","title":"Install strawberry-django-auth"},{"location":"quickstart/#these-captcha-settings-can-not-be-changed-at-runtime","text":"","title":"these (captcha) settings can not be changed at runtime!"},{"location":"quickstart/#since-the-schema-can-not-be-changed-at-runtime","text":"","title":"since the schema can not be changed at runtime."},{"location":"quickstart/#query","text":"","title":"Query"},{"location":"quickstart/#create-the-schema","text":"Create a file called schema.py next to your settings.py with the following: # quickstart.schema.py import strawberry from gqlauth.user.queries import UserQueries from strawberry_django_jwt.middleware import JSONWebTokenMiddleware schema = strawberry . Schema ( query = UserQueries , extensions = [ JSONWebTokenMiddleware , ], ) you can choose what fields to include like this import strawberry from gqlauth.user.queries import UserQueries , UserType from django.contrib.auth import get_user_model @strawberry . django . type ( model = get_user_model ()) class MyQueries : me : UserType = UserQueries . me public : UserType = UserQueries . public_user # etc...","title":"Create the schema"},{"location":"quickstart/#load-fixtures","text":"Before starting to query, let's load some users on the database. Create a new file called users.json in the same directory as manage.py with the following: Have a look on the fixtures, note that we are creating 4 users and 3 UserStatus . When creating a user, we create a relating UserStatus by default on post_save signal with the following fields: verified = False archived = False secondary_email = None You can access it on any user: user.status. [ verified | archived | secondary_email ] [ { \"model\" : \"users.CustomUser\" , \"pk\" : 1 , \"fields\" : { \"password\" : \"pbkdf2_sha256$180000$nFcBtiqGnWN9$hf58wNg77oT1BlNKRdATVVvBIa69+dz22fL1JKOKTaA=\" , \"last_login\" : null , \"is_superuser\" : false , \"username\" : \"user1\" , \"first_name\" : \"\" , \"last_name\" : \"\" , \"email\" : \"user1@email.com\" , \"is_staff\" : false , \"is_active\" : true } }, { \"model\" : \"users.CustomUser\" , \"pk\" : 2 , \"fields\" : { \"password\" : \"pbkdf2_sha256$180000$nFcBtiqGnWN9$hf58wNg77oT1BlNKRdATVVvBIa69+dz22fL1JKOKTaA=\" , \"last_login\" : null , \"is_superuser\" : false , \"username\" : \"user2\" , \"first_name\" : \"\" , \"last_name\" : \"\" , \"email\" : \"user2@email.com\" , \"is_staff\" : false , \"is_active\" : true } }, { \"model\" : \"gqlauth.userstatus\" , \"pk\" : 2 , \"fields\" : { \"user\" : 2 , \"verified\" : true , \"archived\" : false , \"secondary_email\" : null } }, { \"model\" : \"users.CustomUser\" , \"pk\" : 3 , \"fields\" : { \"password\" : \"pbkdf2_sha256$180000$nFcBtiqGnWN9$hf58wNg77oT1BlNKRdATVVvBIa69+dz22fL1JKOKTaA=\" , \"last_login\" : null , \"is_superuser\" : false , \"username\" : \"user3\" , \"first_name\" : \"\" , \"last_name\" : \"\" , \"email\" : \"user3@email.com\" , \"is_staff\" : false , \"is_active\" : true } }, { \"model\" : \"gqlauth.userstatus\" , \"pk\" : 3 , \"fields\" : { \"user\" : 3 , \"verified\" : true , \"archived\" : true , \"secondary_email\" : null } }, { \"model\" : \"users.CustomUser\" , \"pk\" : 4 , \"fields\" : { \"password\" : \"pbkdf2_sha256$180000$nFcBtiqGnWN9$hf58wNg77oT1BlNKRdATVVvBIa69+dz22fL1JKOKTaA=\" , \"last_login\" : null , \"is_superuser\" : false , \"username\" : \"user4\" , \"first_name\" : \"\" , \"last_name\" : \"\" , \"email\" : \"user4@email.com\" , \"is_staff\" : false , \"is_active\" : true } }, { \"model\" : \"gqlauth.userstatus\" , \"pk\" : 4 , \"fields\" : { \"user\" : 4 , \"verified\" : true , \"archived\" : false , \"secondary_email\" : \"user4_secondary@email.com\" } } ] run: python -m manage loaddata users.json","title":"Load fixtures"},{"location":"quickstart/#making-your-first-query","text":"Start the dev server: python manage.py runserver Open your browser: http://127.0.0.1:8000/graphql This will open the GraphiQL API browser , where you can play with your queries and mutations, also let you explore the schema. Copy the query below, paste on the GraphiQL interface and hit the play button. Gql query response query { users{ username, archived, verified, email, secondaryEmail, } } { \"data\" : { \"users\" : [ { \"username\" : \"user1\" , \"archived\" : false , \"verified\" : false , \"email\" : \"user1@email.com\" , \"secondaryEmail\" : null }, { \"username\" : \"user2\" , \"archived\" : false , \"verified\" : true , \"email\" : \"user2@email.com\" , \"secondaryEmail\" : null }, { \"username\" : \"user3\" , \"archived\" : true , \"verified\" : true , \"email\" : \"user3@email.com\" , \"secondaryEmail\" : null }, { \"username\" : \"user4\" , \"archived\" : false , \"verified\" : true , \"email\" : \"user4@email.com\" , \"secondaryEmail\" : \"user4_secondary@email.com\" } ] } }","title":"Making your first query"},{"location":"quickstart/#query-with-filters","text":"The UserQuery comes with some default filters: Gql query response { users(filters: {status: {archived: true}}) { username archived verified email secondaryEmail } } { \"data\": { \"users\": [ { \"username\": \"user3\", \"archived\": true, \"verified\": true, \"email\": \"user3@email.com\", \"secondaryEmail\": null } ] } } Take a minute to explore the GraphiQL API browser and query schema on the right upper corner under docs tab.","title":"Query with filters"},{"location":"quickstart/#mequery","text":"With MeQuery you can retrieve data for the currently authenticated user: Gql query response query { me { username, verified } } { \"data\": { \"user\": { \"username\": \"new_user\", \"verified\": true } } } Since this query requires an authenticated user it can only be explored by using the insomnia API client . See the below for more on how to use Insomnia.","title":"MeQuery"},{"location":"quickstart/#setup-email-backend","text":"The default configuration is to send activation email when registering users, you can set it to False on your settings , but you still need an Email Backend to password reset. The quickest solution for development is to setup a Console Email Backend , simply add the following to your settings.py . EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend' Now all emails are sent to the standard output, instead of an actual email and we are ready to continue this guide.","title":"Setup Email Backend"},{"location":"quickstart/#mutations","text":"Now let's add some mutations to our schema, starting with the registration. On the schema.py add the following: Register arg_mutations relay # quickstart.schema.py import strawberry from gqlauth.schema import UserQueries from gqlauth.user import arg_mutations from strawberry_django_jwt.middleware import JSONWebTokenMiddleware @strawberry . type class UserMutations : register = arg_mutations . Register . field verify_account = arg_mutations . VerifyAccount . field resend_activation_email = arg_mutations . ResendActivationEmail . field send_password_reset_email = arg_mutations . SendPasswordResetEmail . field password_reset = arg_mutations . PasswordReset . field password_set = arg_mutations . PasswordSet . field password_change = arg_mutations . PasswordChange . field archive_account = arg_mutations . ArchiveAccount . field delete_account = arg_mutations . DeleteAccount . field update_account = arg_mutations . UpdateAccount . field send_secondary_email_activation = arg_mutations . SendSecondaryEmailActivation . field verify_secondary_email = arg_mutations . VerifySecondaryEmail . field swap_emails = arg_mutations . SwapEmails . field captcha = arg_mutations . Cap . field # django-graphql-jwt authentication # with some extra features token_auth = arg_mutations . ObtainJSONWebToken . field verify_token = arg_mutations . VerifyToken . field refresh_token = arg_mutations . RefreshToken . field revoke_token = arg_mutations . RevokeToken . field schema = strawberry . Schema ( query = UserQueries , mutation = UserMutations , extensions = [ JSONWebTokenMiddleware , ], ) # quickstart.schema.py import strawberry from gqlauth.schema import UserQueries from gqlauth.user import relay from strawberry_django_jwt.middleware import JSONWebTokenMiddleware @strawberry . type class UserMutations : register = relay . Register . field verify_account = relay . VerifyAccount . field resend_activation_email = relay . ResendActivationEmail . field send_password_reset_email = relay . SendPasswordResetEmail . field password_reset = relay . PasswordReset . field password_set = relay . PasswordSet . field password_change = relay . PasswordChange . field archive_account = relay . ArchiveAccount . field delete_account = relay . DeleteAccount . field update_account = relay . UpdateAccount . field send_secondary_email_activation = relay . SendSecondaryEmailActivation . field verify_secondary_email = relay . VerifySecondaryEmail . field swap_emails = relay . SwapEmails . field captcha = relay . Cap . field # django-graphql-jwt authentication # with some extra features token_auth = relay . ObtainJSONWebToken . field verify_token = relay . VerifyToken . field refresh_token = relay . RefreshToken . field revoke_token = relay . RevokeToken . field schema = strawberry . Schema ( query = UserQueries , mutation = UserMutations , extensions = [ JSONWebTokenMiddleware , ], ) Take a minute to explore the schema on the documentation tab again.","title":"Mutations"},{"location":"quickstart/#lets-try-to-register-a-new-user","text":"Failure gql relay response mutation { register( email: \"new_user@email.com\", username: \"new_user\", password1: \"123456\", password2: \"123456\", ) { success, errors, } } mutation { register( input: { email: \"new_user@email.com\", username: \"new_user\", password1: \"123456\", password2: \"123456\", } ) { success, errors, token, refreshToken } } { \"data\" : { \"register\" : { \"success\" : false , \"errors\" : { \"password2\" : [ { \"message\" : \"This password is too short. It must contain at least 8 characters.\" , \"code\" : \"password_too_short\" }, { \"message\" : \"This password is too common.\" , \"code\" : \"password_too_common\" }, { \"message\" : \"This password is entirely numeric.\" , \"code\" : \"password_entirely_numeric\" } ] } } } } Something went wrong! Now you know the response format that you can expect of all mutations. Let's try again: Success arg_mutation relay response mutation { register( email: \"new_user@email.com\", username: \"new_user\", password1: \"SuperSecureP@sw0rd\", password2: \"SuperSecureP@sw0rd\", ) { success, errors, success } } mutation { register( input: { email: \"new_user@email.com\", username: \"new_user\", password1: \"SuperSecureP@sw0rd\", password2: \"SuperSecureP@sw0rd\", } ) { success, errors, token, refreshToken } } { \"data\" : { \"register\" : { \"success\" : true , \"errors\" : null } } } Now Check if the new user is really on the database: Check query response query{ users(filters: {username: \"new_user\"}) { id username email isActive archived, verified, secondaryEmail } } { \"data\" : { \"users\" : [ { \"id\" : \"5\" , \"username\" : \"new_user\" , \"email\" : \"new_user@email.com\" , \"isActive\" : true , \"archived\" : false , \"verified\" : false , \"secondaryEmail\" : null } ] } } There is actually a new user and it is possible to log in (you can change it on the settings ), but it is not verified yet. Save the id of the new user, so we can query it later. Go to your console and note the email that has been sent. Should be two outputs, html and plain text formats. Save the token from the url, something like this: eyJ1c2VybmFtZSI6Im5ld191c2VyIiwiYWN0aW9uIjoiYWN0aXZhdGlvbiJ9:1isoSr:CDwK_fjBSxWj3adC-X16wqzv-Mw","title":"Let's try to register a new user:"},{"location":"quickstart/#account-verification","text":"search your schema for verify_account : should look like this:","title":"Account Verification"},{"location":"quickstart/#now-lets-try-to-verify-the-account","text":"Gql arg_mutation relay result mutation { verifyAccount(token: \"YOUR TOKEN HERE\") { success, errors } } mutation { verifyAccount ( input : { token : \"<YOUR TOKEN HERE>\" } ) { success , errors } } { \"data\" : { \"verifyAccount\" : { \"success\" : true , \"errors\" : null } } } Check if the user is verified using the id that you have saved early: Gql query response query { user (pk: \"<USER ID>\"){ username, verified } } { \"data\" : { \"user\" : { \"username\" : \"new_user\" , \"verified\" : true } } }","title":"Now let's try to verify the account:"},{"location":"quickstart/#login","text":"search your schema for tokenAuth : should look like this:","title":"Login"},{"location":"quickstart/#lets-try-to-login","text":"Gql arg_mutation relay response mutation { tokenAuth(username: \"new_user\", password: \"SuperSecureP@sw0rd\") { success errors obtainPayload { token refreshToken refreshExpiresIn payload { exp origIat username } } } } mutation login { tokenAuth(input: {username: \"new_user\", password: \"SuperSecureP@sw0rd\"}) { success errors obtainPayload { token refreshToken refreshExpiresIn payload { exp origIat username } } } } { \"data\" : { \"tokenAuth\" : { \"success\" : true , \"errors\" : null , \"obtainPayload\" : { \"token\" : \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE2NTM2MDkxOTQsIm9yaWdJYXQiOjE2NTM2MDg4OTQsInVzZXJuYW1lIjoibmV3X3VzZXIxIn0.FxXaWKToi5mTzPcKAz16K2GWnIvsTBKio_BEyCdF5fs\" , \"refreshToken\" : \"e7a784476810f880eb93f3827cd881d834235598\" , \"refreshExpiresIn\" : 1654213694 , \"payload\" : { \"exp\" : 1653609194 , \"origIat\" : 1653608894 , \"username\" : \"new_user1\" } } } } } Save this token , we are going to use it to do some protected actions. The GraphiQL interface that comes with Graphene is great! But to try all features, we need to send this token on the header and the GraphiQL do not support this.","title":"Let's try to login:"},{"location":"quickstart/#insomnia-api-client","text":"We are going to use insomnia API client to send request with authorization header. It is really easy to setup, simple follow the instructions on the site. Install and come back here!","title":"Insomnia API client"},{"location":"quickstart/#update-account","text":"search in your schema for updateAccount it should look like this: This is the first mutation with login required that we are going to test. On the insomnia, create a new request and call it updateAccount . Select the method POST . On the top of the window, add your graphql url: http://127.0.0.1:8000/graphql For the body, select GraphQL Query . Now it works exactly as the graphiQL. On the headers pane, create a new header: name: Authorization value: JWT <TOKEN FROM THE LOGIN> Make the query: Gql arg_mutation relay response mutation { updateAccount( firstName: \"Joe\" ) { success, errors } } mutation { updateAccount( input: { firstName: \"Joe\" } ) { success, errors } } { \"data\" : { \"updateAccount\" : { \"success\" : true , \"errors\" : null } } } If it fails because of the token (in case you took some time and it has expired), make the login again and get a new token. Check if it worked: Gql query response query { user (id: \"<USER ID>\"){ username, firstName } } { \"data\" : { \"user\" : { \"username\" : \"new_user\" , \"firstName\" : \"Joe\" } } }","title":"Update Account"},{"location":"quickstart/#next-steps","text":"explore all the mutations. Navigate through the GraphiQL Documentation Explorer. Change the settings . Explore the api . check our decorators . make sure you are familiar with our captcha system. Override email templates . Explore these useful links .","title":"Next steps"},{"location":"relay/","text":"Relay \u00b6 Import mutations from the relay module: import strawberry from gqlauth.user import relay @strawberry . type class AuthMutation : register = relay . Register . field Note that relay is not supported for queries yet. \u00b6","title":"Relay"},{"location":"relay/#relay","text":"Import mutations from the relay module: import strawberry from gqlauth.user import relay @strawberry . type class AuthMutation : register = relay . Register . field","title":"Relay"},{"location":"relay/#note-that-relay-is-not-supported-for-queries-yet","text":"","title":"Note that relay is not supported for queries yet."},{"location":"settings/","text":"Settings \u00b6 Example \u00b6 Configuration is made from a single Django setting named GQL_AUTH . # settings.py from gqlauth.settings_type import GqlAuthSettings GQL_AUTH = GqlAuthSettings ( LOGIN_ALLOWED_FIELDS = [ 'email' , 'username' ], ) Warning these settings can not be changed at runtime! \u00b6 since the schema can not be changed at runtime. \u00b6 Boolean Flags \u00b6 ALLOW_LOGIN_NOT_VERIFIED \u00b6 Determines whether the user can log in without being verified. If it is true, the registering returns token and refresh token on the output. default: True ALLOW_LOGIN_WITH_SECONDARY_EMAIL \u00b6 If a user has a secondary email set, he can use to login. default: True ALLOW_PASSWORDLESS_REGISTRATION \u00b6 To allow registration with no password; Django set_unusable_password() will be used in setting the default password. User cannot login until they set their password default: False ALLOW_DELETE_ACCOUNT \u00b6 Instead of deleting the account, make user . is_active = False . If set to True , will actually delete the account. default: False SEND_ACTIVATION_EMAIL \u00b6 If set to False , no email will be sent. Note that users will still have an verified = False status. default: True SEND_PASSWORD_SET_EMAIL \u00b6 If set to True , user will be notified to set their password after registration - dependent on ALLOW_PASSWORDLESS_REGISTRATION . default: False Dynamic Fields \u00b6 Fields that you can choose. Basics \u00b6 All fields should match name in the user model field. * Can be a list of string fields or a dictionary mapping fields and graphene base scalars . Example: update_fields_list = [ \"first_name\" , \"last_name\" ] # same as: update_fields_dict = { \"first_name\" : \"String\" , \"last_name\" : \"String\" , } # maybe you have some Int that you want on registration: REGISTER_MUTATION_FIELDS = { \"email\" : \"String\" , \"username\" : \"String\" , \"luck_number\" : \"Int\" , } LOGIN_ALLOWED_FIELDS \u00b6 default: [ \"email\" , \"username\" ] REGISTER_MUTATION_FIELDS \u00b6 Required fields on registration, along with password1 and password2 . default: [ \"email\" , \"username\" ] REGISTER_MUTATION_FIELDS_OPTIONAL \u00b6 Optional fields on registration. default: [] UPDATE_MUTATION_FIELDS \u00b6 Optional fields on update account. default: [ \"first_name\" , \"last_name\" ] CUSTOM_ERROR_TYPE \u00b6 Customize mutations error output by providing a Graphene type. default: gqlauth.types.ExpectedErrorType example: class CustomErrorType ( graphene . Scalar ): @staticmethod def serialize ( errors ): return { \"my_custom_error_format\" } Query \u00b6 USER_NODE_FILTER_FIELDS \u00b6 Learn more on graphene django and django filter . default: { \"email\" : [ \"exact\" ,], \"username\" : [ \"exact\" , \"icontains\" , \"istartswith\" ], \"is_active\" : [ \"exact\" ], \"status__archived\" : [ \"exact\" ], \"status__verified\" : [ \"exact\" ], \"status__secondary_email\" : [ \"exact\" ], } USER_NODE_EXCLUDE_FIELDS \u00b6 default: [ \"password\" , \"is_superuser\" ] Token expirations \u00b6 EXPIRATION_ACTIVATION_TOKEN \u00b6 default: timedelta ( days = 7 ) EXPIRATION_PASSWORD_RESET_TOKEN \u00b6 default: timedelta ( hours = 1 ) EXPIRATION_SECONDARY_EMAIL_ACTIVATION_TOKEN \u00b6 default: timedelta ( hours = 1 ) EXPIRATION_PASSWORD_SET_TOKEN \u00b6 default: timedelta ( days = 7 ) Email \u00b6 EMAIL_FROM \u00b6 It will get the default value from your settings, but you can provide a specific email. default: getattr ( django_settings , \"DEFAULT_FROM_EMAIL\" , \"test@email.com\" ) ACTIVATION_PATH_ON_EMAIL \u00b6 Path variable used in activation email. default: \"activate\" PASSWORD_RESET_PATH_ON_EMAIL \u00b6 Path variable used in password reset email. default: \"password-reset\" PASSWORD_SET_PATH_ON_EMAIL \u00b6 Path variable used in password set email. default: \"password-set\" ACTIVATION_SECONDARY_EMAIL_PATH_ON_EMAIL \u00b6 Path variable used in secondary email activation email. default: \"activate\" Email subject templates \u00b6 You can override email templates as shown here , but you can also change the templates names. EMAIL_SUBJECT_ACTIVATION \u00b6 default: \"email/activation_subject.txt\" EMAIL_SUBJECT_ACTIVATION_RESEND \u00b6 default: \"email/activation_subject.txt\" EMAIL_SUBJECT_SECONDARY_EMAIL_ACTIVATION \u00b6 default: \"email/activation_subject.txt\" EMAIL_SUBJECT_PASSWORD_RESET \u00b6 default: \"email/password_reset_subject.txt\" EMAIL_SUBJECT_PASSWORD_SET \u00b6 default: \"email/password_set_subject.txt\" Email templates \u00b6 You can override email templates as shown here , but you can also change the templates names. EMAIL_TEMPLATE_ACTIVATION \u00b6 default: \"email/activation_email.html\" EMAIL_TEMPLATE_ACTIVATION_RESEND \u00b6 default: \"email/activation_email.html\" EMAIL_TEMPLATE_SECONDARY_EMAIL_ACTIVATION \u00b6 default: \"email/activation_email.html\" EMAIL_TEMPLATE_PASSWORD_RESET \u00b6 default: \"email/password_reset_email.html\" EMAIL_TEMPLATE_PASSWORD_SET \u00b6 default: \"email/password_set_email.html\" EMAIL_TEMPLATE_VARIABLES \u00b6 default: {} Dictionary of key value pairs of template variables that will be injected into the templates. Example: GRAPHQL_AUTH = { \"EMAIL_TEMPLATE_VARIABLES\" : { \"frontend_domain\" : \"the-frontend.com\" } } Now, in the templates: < p > {{ protocol }}://{{ frontend_domain }}/{{ path }}/{{ token }} </ p >","title":"Settings"},{"location":"settings/#settings","text":"","title":"Settings"},{"location":"settings/#example","text":"Configuration is made from a single Django setting named GQL_AUTH . # settings.py from gqlauth.settings_type import GqlAuthSettings GQL_AUTH = GqlAuthSettings ( LOGIN_ALLOWED_FIELDS = [ 'email' , 'username' ], ) Warning","title":"Example"},{"location":"settings/#these-settings-can-not-be-changed-at-runtime","text":"","title":"these settings can not be changed at runtime!"},{"location":"settings/#since-the-schema-can-not-be-changed-at-runtime","text":"","title":"since the schema can not be changed at runtime."},{"location":"settings/#boolean-flags","text":"","title":"Boolean Flags"},{"location":"settings/#allow_login_not_verified","text":"Determines whether the user can log in without being verified. If it is true, the registering returns token and refresh token on the output. default: True","title":"ALLOW_LOGIN_NOT_VERIFIED"},{"location":"settings/#allow_login_with_secondary_email","text":"If a user has a secondary email set, he can use to login. default: True","title":"ALLOW_LOGIN_WITH_SECONDARY_EMAIL"},{"location":"settings/#allow_passwordless_registration","text":"To allow registration with no password; Django set_unusable_password() will be used in setting the default password. User cannot login until they set their password default: False","title":"ALLOW_PASSWORDLESS_REGISTRATION"},{"location":"settings/#allow_delete_account","text":"Instead of deleting the account, make user . is_active = False . If set to True , will actually delete the account. default: False","title":"ALLOW_DELETE_ACCOUNT"},{"location":"settings/#send_activation_email","text":"If set to False , no email will be sent. Note that users will still have an verified = False status. default: True","title":"SEND_ACTIVATION_EMAIL"},{"location":"settings/#send_password_set_email","text":"If set to True , user will be notified to set their password after registration - dependent on ALLOW_PASSWORDLESS_REGISTRATION . default: False","title":"SEND_PASSWORD_SET_EMAIL"},{"location":"settings/#dynamic-fields","text":"Fields that you can choose.","title":"Dynamic Fields"},{"location":"settings/#basics","text":"All fields should match name in the user model field. * Can be a list of string fields or a dictionary mapping fields and graphene base scalars . Example: update_fields_list = [ \"first_name\" , \"last_name\" ] # same as: update_fields_dict = { \"first_name\" : \"String\" , \"last_name\" : \"String\" , } # maybe you have some Int that you want on registration: REGISTER_MUTATION_FIELDS = { \"email\" : \"String\" , \"username\" : \"String\" , \"luck_number\" : \"Int\" , }","title":"Basics"},{"location":"settings/#login_allowed_fields","text":"default: [ \"email\" , \"username\" ]","title":"LOGIN_ALLOWED_FIELDS"},{"location":"settings/#register_mutation_fields","text":"Required fields on registration, along with password1 and password2 . default: [ \"email\" , \"username\" ]","title":"REGISTER_MUTATION_FIELDS"},{"location":"settings/#register_mutation_fields_optional","text":"Optional fields on registration. default: []","title":"REGISTER_MUTATION_FIELDS_OPTIONAL"},{"location":"settings/#update_mutation_fields","text":"Optional fields on update account. default: [ \"first_name\" , \"last_name\" ]","title":"UPDATE_MUTATION_FIELDS"},{"location":"settings/#custom_error_type","text":"Customize mutations error output by providing a Graphene type. default: gqlauth.types.ExpectedErrorType example: class CustomErrorType ( graphene . Scalar ): @staticmethod def serialize ( errors ): return { \"my_custom_error_format\" }","title":"CUSTOM_ERROR_TYPE"},{"location":"settings/#query","text":"","title":"Query"},{"location":"settings/#user_node_filter_fields","text":"Learn more on graphene django and django filter . default: { \"email\" : [ \"exact\" ,], \"username\" : [ \"exact\" , \"icontains\" , \"istartswith\" ], \"is_active\" : [ \"exact\" ], \"status__archived\" : [ \"exact\" ], \"status__verified\" : [ \"exact\" ], \"status__secondary_email\" : [ \"exact\" ], }","title":"USER_NODE_FILTER_FIELDS"},{"location":"settings/#user_node_exclude_fields","text":"default: [ \"password\" , \"is_superuser\" ]","title":"USER_NODE_EXCLUDE_FIELDS"},{"location":"settings/#token-expirations","text":"","title":"Token expirations"},{"location":"settings/#expiration_activation_token","text":"default: timedelta ( days = 7 )","title":"EXPIRATION_ACTIVATION_TOKEN"},{"location":"settings/#expiration_password_reset_token","text":"default: timedelta ( hours = 1 )","title":"EXPIRATION_PASSWORD_RESET_TOKEN"},{"location":"settings/#expiration_secondary_email_activation_token","text":"default: timedelta ( hours = 1 )","title":"EXPIRATION_SECONDARY_EMAIL_ACTIVATION_TOKEN"},{"location":"settings/#expiration_password_set_token","text":"default: timedelta ( days = 7 )","title":"EXPIRATION_PASSWORD_SET_TOKEN"},{"location":"settings/#email","text":"","title":"Email"},{"location":"settings/#email_from","text":"It will get the default value from your settings, but you can provide a specific email. default: getattr ( django_settings , \"DEFAULT_FROM_EMAIL\" , \"test@email.com\" )","title":"EMAIL_FROM"},{"location":"settings/#activation_path_on_email","text":"Path variable used in activation email. default: \"activate\"","title":"ACTIVATION_PATH_ON_EMAIL"},{"location":"settings/#password_reset_path_on_email","text":"Path variable used in password reset email. default: \"password-reset\"","title":"PASSWORD_RESET_PATH_ON_EMAIL"},{"location":"settings/#password_set_path_on_email","text":"Path variable used in password set email. default: \"password-set\"","title":"PASSWORD_SET_PATH_ON_EMAIL"},{"location":"settings/#activation_secondary_email_path_on_email","text":"Path variable used in secondary email activation email. default: \"activate\"","title":"ACTIVATION_SECONDARY_EMAIL_PATH_ON_EMAIL"},{"location":"settings/#email-subject-templates","text":"You can override email templates as shown here , but you can also change the templates names.","title":"Email subject templates"},{"location":"settings/#email_subject_activation","text":"default: \"email/activation_subject.txt\"","title":"EMAIL_SUBJECT_ACTIVATION"},{"location":"settings/#email_subject_activation_resend","text":"default: \"email/activation_subject.txt\"","title":"EMAIL_SUBJECT_ACTIVATION_RESEND"},{"location":"settings/#email_subject_secondary_email_activation","text":"default: \"email/activation_subject.txt\"","title":"EMAIL_SUBJECT_SECONDARY_EMAIL_ACTIVATION"},{"location":"settings/#email_subject_password_reset","text":"default: \"email/password_reset_subject.txt\"","title":"EMAIL_SUBJECT_PASSWORD_RESET"},{"location":"settings/#email_subject_password_set","text":"default: \"email/password_set_subject.txt\"","title":"EMAIL_SUBJECT_PASSWORD_SET"},{"location":"settings/#email-templates","text":"You can override email templates as shown here , but you can also change the templates names.","title":"Email templates"},{"location":"settings/#email_template_activation","text":"default: \"email/activation_email.html\"","title":"EMAIL_TEMPLATE_ACTIVATION"},{"location":"settings/#email_template_activation_resend","text":"default: \"email/activation_email.html\"","title":"EMAIL_TEMPLATE_ACTIVATION_RESEND"},{"location":"settings/#email_template_secondary_email_activation","text":"default: \"email/activation_email.html\"","title":"EMAIL_TEMPLATE_SECONDARY_EMAIL_ACTIVATION"},{"location":"settings/#email_template_password_reset","text":"default: \"email/password_reset_email.html\"","title":"EMAIL_TEMPLATE_PASSWORD_RESET"},{"location":"settings/#email_template_password_set","text":"default: \"email/password_set_email.html\"","title":"EMAIL_TEMPLATE_PASSWORD_SET"},{"location":"settings/#email_template_variables","text":"default: {} Dictionary of key value pairs of template variables that will be injected into the templates. Example: GRAPHQL_AUTH = { \"EMAIL_TEMPLATE_VARIABLES\" : { \"frontend_domain\" : \"the-frontend.com\" } } Now, in the templates: < p > {{ protocol }}://{{ frontend_domain }}/{{ path }}/{{ token }} </ p >","title":"EMAIL_TEMPLATE_VARIABLES"}]}